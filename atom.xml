<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://mercurycity.github.io</id>
    <title>Mercury的小屋</title>
    <updated>2021-07-13T03:42:50.664Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://mercurycity.github.io"/>
    <link rel="self" href="https://mercurycity.github.io/atom.xml"/>
    <subtitle>刘玖拾的一个小屋，专门端捧刘玖拾的梦想。</subtitle>
    <logo>https://mercurycity.github.io/images/avatar.png</logo>
    <icon>https://mercurycity.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Mercury的小屋</rights>
    <entry>
        <title type="html"><![CDATA[关于树形dp的专题探究]]></title>
        <id>https://mercurycity.github.io/post/guan-yu-shu-xing-dp-de-zhuan-ti-tan-jiu/</id>
        <link href="https://mercurycity.github.io/post/guan-yu-shu-xing-dp-de-zhuan-ti-tan-jiu/">
        </link>
        <updated>2021-07-13T03:09:57.000Z</updated>
        <content type="html"><![CDATA[<p>2021夏令营刚好学了树形dp，很有感觉，所以专门写一个关于树形dp的专题探究。</p>
<p>好，首先树形dp的关键的框架。</p>
<pre><code class="language-cpp">void dfs(int u,int fa){
    ///Do something
    for(int i=0;i&lt;a[u].size();++i){
        //Do something
        int v=a[u][i];
        if(v==fa) continue;
        //Do something
    }
    return;
}
</code></pre>
<p>这个框架真的很有用。</p>
<p>树形dp的主要关系就在于处理一下一个节点和他儿子所要求的东西的关系。</p>
<p>上来点题目试试！</p>
<h2 id="树的直径简化版">树的直径(简化版)</h2>
<h4 id="题目描述">题目描述</h4>
<p>小Q最近学习了一些图论知识。根据课本，有如下定义。树：无回路且连通的无向图，每条边都有正整数的权值来表示其长度。如果一棵树有N个节点，可以证明其有且仅有N-1 条边。 路径：一棵树上，任意两个节点之间最多有一条简单路径。我们用 dis(a,b)表示点a和点b的路径上各边长度之和。称dis(a,b)为a、b两个节点间的距离。<br>
直径：一棵树上，最长的路径为树的直径。树的直径可能不是唯一的。<br>
现在小Q想知道，对于给定的一棵树，其直径的长度是多少？（以及有多少条边满足所有的直径都经过该边，不需要计算，供思考 ）</p>
<h4 id="输入格式">输入格式</h4>
<p>第一行包含一个整数N，表示节点数。<br>
接下来N-1行，每行三个整数a, b, c ，表示点 a和点b之间有一条长度为c的无向边。</p>
<h4 id="输出格式">输出格式</h4>
<p>一行一个整数，表示直径的长度。</p>
<h4 id="数据范围与提示">数据范围与提示</h4>
<p>对于100%的测试数据：2≤N≤200000，所有点的编号都在1..N的范围内，<br>
边的权值≤10^9。</p>
<h4 id="输入样例">输入样例</h4>
<p>6<br>
3 1 1000<br>
1 4 10<br>
4 2 100<br>
4 5 50<br>
4 6 100</p>
<h4 id="输出样例">输出样例</h4>
<p>1110</p>
<h4 id="样例说明">样例说明</h4>
<p>直径共有两条，3 到2的路径和3到6的路径。这两条直径都经过边(3, 1)和边(1, 4)。</p>
<h4 id="思路">思路</h4>
<p>模板题，树的直径。</p>
<p>考虑的是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>u</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f[u]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">u</span><span class="mclose">]</span></span></span></span> 表示现在在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span> 点的往下的最长的一条链。</p>
<p>现在考虑一下第二问怎么解答，虽然他并没有要求解答。有多少条直径，那么我现在先保存一个最大值，然后判断这个最大值被更新过多少次就ok了。</p>
<p>上die码：</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
template &lt;typename T&gt;inline void read(T&amp; t){
    t=0; register char ch=getchar();
    while(!('0'&lt;=ch&amp;&amp;ch&lt;='9')){if(ch=='-') t=-1;ch=getchar();}
    while(('0'&lt;=ch&amp;&amp;ch&lt;='9')){t=((t&lt;&lt;1)+(t&lt;&lt;3))+ch-'0'; ch=getchar();}
}
template &lt;typename T,typename... Args&gt; inline void read(T&amp; t, Args&amp;... args){
    read(t);read(args...);
}
template &lt;typename T&gt;inline void write(T x){
    if(x&lt;0) putchar('-'),x=~(x-1); int s[40],top=0;
    while(x) s[++top]=x%10,x/=10; if(!top) s[++top]=0;
    while(top) putchar(s[top--]+'0');
}
long long dis[314514],n,m;
char ch;
vector&lt;pair&lt;int,int&gt; &gt;a[314514];
long long ans;
void dfs(int u,int fa){
    for(int i=0;i&lt;a[u].size();++i){
        int v=a[u][i].first;
        if(v==fa) continue;
        dfs(v,u);
        ans=max(ans,a[u][i].second+dis[v]+dis[u]);
        dis[u]=max(dis[v]+a[u][i].second,dis[u]);
    }
}
int main(){
    cin&gt;&gt;n;
    for(int i=1;i&lt;n;++i){
        int x,y,w;
        read(x,y,w);
        a[x].push_back(make_pair(y,w));
        a[y].push_back(make_pair(x,w));
    }
    dfs(1,-1);
    cout&lt;&lt;ans&lt;&lt;endl;
    return 0;
}
</code></pre>
<h2 id="电脑网络">电脑网络</h2>
<h4 id="题目描述-2">题目描述</h4>
<p>一所学校在几年前购进了第一台电脑（这台电脑的编号为1）。最近几年，学校又购买了N-1台电脑，每台新电脑和之前的某一台电脑连接。学校的管理员想知道对于每一台电脑i，到与它距离最远的电脑的距离Si。你需要提供这个信息。<br>
<img src="https://z3.ax1x.com/2021/07/13/WkN65d.png" alt="" loading="lazy"><br>
Hint: 样例输入如上图所示，从图中你可以知道，4号电脑到1号电脑的距离最远，所以S1=3。4号电脑和5号电脑到2号电脑的距离最远，所以S2=2。5号电脑到3号电脑距离最远，所以S3=3。由此类推S4=4，S5=4。</p>
<h4 id="输入格式-2">输入格式</h4>
<p>第一行包含一个整数N (N&lt;=10000) ；<br>
接下来N-1行描述每一台电脑。第i行包含两个用空格隔开的整数y、l，表示i号电脑与之前的y号电脑连接，距离为l。<br>
所有l之和不超过10^9。</p>
<h4 id="输出格式-2">输出格式</h4>
<p>对于每组测试数据输出N行，第i行表示离i号电脑的最远距离Si。</p>
<h4 id="样例输入">样例输入</h4>
<p>5<br>
1 1<br>
2 1<br>
3 1<br>
1 1</p>
<h4 id="样例输出">样例输出</h4>
<p>3<br>
2<br>
3<br>
4<br>
4</p>
<h4 id="思路-2">思路</h4>
<p>这道题目运用了我认为一个巧妙的结论，在讲树的直径的时候也讲过了。</p>
<p>原来求树的直径，从一个点到他最远的点，然后再从那个最远的点到相对于它来说最远的点。</p>
<p>这说明什么，一个点到它最远的点肯定在树的直径的端点上。</p>
<p>那么就好办了，直接用三次dfs，第一次找到一个端点，第二次找到两个端点顺便记录一下从第一个找到端点到所有点的距离，第三次记录第二个找到的端点到所有点的距离，最后在两个距离里面取一个最大值就ok了。</p>
<h4 id="蒟蒻die码">蒟蒻die码：</h4>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define pb push_back
using namespace std;
template &lt;typename T&gt;inline void read(T&amp; t){
    t=0; register char ch=getchar();
    while(!('0'&lt;=ch&amp;&amp;ch&lt;='9')){if(ch=='-') t=-1;ch=getchar();}
    while(('0'&lt;=ch&amp;&amp;ch&lt;='9')){t=((t&lt;&lt;1)+(t&lt;&lt;3))+ch-'0'; ch=getchar();}
}
template &lt;typename T,typename... Args&gt; inline void read(T&amp; t, Args&amp;... args){
    read(t);read(args...);
}
template &lt;typename T&gt;inline void write(T x){
    if(x&lt;0) putchar('-'),x=~(x-1); int s[40],top=0;
    while(x) s[++top]=x%10,x/=10; if(!top) s[++top]=0;
    while(top) putchar(s[top--]+'0');
}
int n;
int dis[114514];
int dis1[114514];
vector&lt;pair&lt;int,int&gt; &gt;a[114514];
void dfs(int u,int fa){
    for(int i=0;i&lt;a[u].size();++i){
        int v=a[u][i].first;
        if(v==fa) continue;
        dis[v]=dis[u]+a[u][i].second;
        dfs(v,u);
    }
}
void dfs1(int u,int fa){
    for(int i=0;i&lt;a[u].size();++i){
        int v=a[u][i].first;
        if(v==fa) continue;
        dis1[v]=dis1[u]+a[u][i].second;
        dfs1(v,u);
    }
}
int main(){
    cin&gt;&gt;n;
    for(int i=2;i&lt;=n;++i){
        int x,y;
        read(x,y);
        a[i].push_back(make_pair(x,y));
        a[x].push_back(make_pair(i,y));
    }
    dfs(1,-1);
    int maxn=0,maxnum=0;
    for(int i=1;i&lt;=n;++i)
        if(dis[i]&gt;maxn){
            maxn=dis[i];
            maxnum=i;
        }
    dfs1(maxnum,-1);
    maxn=0,maxnum=0;
    for(int i=1;i&lt;=n;++i)
        if(dis1[i]&gt;maxn){
            maxn=dis1[i];
            maxnum=i;        
        }
    memset(dis,0,sizeof(dis));
    dfs(maxnum,-1);
    for(int i=1;i&lt;=n;++i)
        cout&lt;&lt;max(dis[i],dis1[i])&lt;&lt;endl;
    return 0;
}
</code></pre>
<h2 id="医院设置">医院设置</h2>
<h4 id="题目描述-3">题目描述</h4>
<p>设有一棵二叉树（如图，其中圈中的数字表示结点中居民的人口，圈边上数字表示结点编号。现在要求在某个结点上建立一个医院，使所有居民所走的路程之和为最小，同时约定，相邻结点之间的距离为 1。就本图而言，若医院建在 1 处，则距离和 =4+12+220+240=136；若医院建在 3 处，则距离和 =4*2+13+20+40=81…<br>
<img src="https://jsoi.jzhx.net/file/20200312030855_20200312.png" alt="" loading="lazy"></p>
<h4 id="输入格式-3">输入格式</h4>
<p>第一行一个整数 n，表示树的结点数(n≤100)。 接下来的 n 行每行描述了一个结点的状况，包含三个整数，整数之间用空格（一个或多个）分隔，其中：第一个数为居民人口数；第二个数为左链接，为 0 表示无链接；第三个数为右链接，为 0 表示无链接。</p>
<h4 id="输出格式-3">输出格式</h4>
<p>一个整数，表示最小距离和。</p>
<h4 id="输入样例-2">输入样例</h4>
<p>5<br>
13 2 3<br>
4 0 0<br>
12 4 5<br>
20 0 0<br>
40 0 0</p>
<h4 id="输出样例-2">输出样例</h4>
<p>81</p>
<h4 id="思路-3">思路</h4>
<p>这道题数据量不是很大，才100，我现在用Floyd算法直接算答案都可以过，但是如果我这个数据在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup></mrow><annotation encoding="application/x-tex">1 \times 10^6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span> ，那么就必须用我这种 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 的办法了</p>
<p>首先思考，如果我现在已经确定了医院的位置并且算好了结果。</p>
<figure data-type="image" tabindex="1"><img src="https://z3.ax1x.com/2021/07/13/WkwfYQ.png" alt="" loading="lazy"></figure>
<p>首先看这个图，表示了如果我现在医院就建在一号节点的情况，这样处理是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 的算法。</p>
<p>然后，我现在医院变更了，</p>
<figure data-type="image" tabindex="2"><img src="https://z3.ax1x.com/2021/07/13/WkwWFg.png" alt="" loading="lazy"></figure>
<p>就像这个图，我现在医院变更了，可以看到，蓝色区域的节点都少走了已一步路，而其他节点都多走了一步路。</p>
<p>这叫做换根操作。请出换根的终极公式：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>v</mi><mo>]</mo><mo>=</mo><mi>f</mi><mo>[</mo><mi>u</mi><mo>]</mo><mo>−</mo><mi>c</mi><mi>u</mi><mi>t</mi><mo>[</mo><mi>v</mi><mo>]</mo><mo>∗</mo><mn>2</mn><mo>+</mo><mi>c</mi><mi>u</mi><mi>t</mi><mo>[</mo><mi>u</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f[v]=f[u]-cut[v]*2+cut[u] 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">u</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault">u</span><span class="mclose">]</span></span></span></span></span></p>
<p>ok了，下面就上die码：</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define pb push_back
using namespace std;
template &lt;typename T&gt;inline void read(T&amp; t){
    t=0; register char ch=getchar();
    while(!('0'&lt;=ch&amp;&amp;ch&lt;='9')){if(ch=='-') t=-1;ch=getchar();}
    while(('0'&lt;=ch&amp;&amp;ch&lt;='9')){t=((t&lt;&lt;1)+(t&lt;&lt;3))+ch-'0'; ch=getchar();}
}
template &lt;typename T,typename... Args&gt; inline void read(T&amp; t, Args&amp;... args){
    read(t);read(args...);
}
template &lt;typename T&gt;inline void write(T x){
    if(x&lt;0) putchar('-'),x=~(x-1); int s[40],top=0;
    while(x) s[++top]=x%10,x/=10; if(!top) s[++top]=0;
    while(top) putchar(s[top--]+'0');
}
int n;
struct Node{
    int p,lc,rc;
}a[114514];
int f[114514],s[114514];
void dfs(int u,int s){
    f[1]+=s*a[u].p;
    if(a[u].lc) dfs(a[u].lc,s+1);
    if(a[u].rc) dfs(a[u].rc,s+1);
    return;
}
void dfss(int u,int fa){
    s[u]=a[u].p;
    if(a[u].lc){
        dfss(a[u].lc,u);
        s[u]+=s[a[u].lc];
    }
    if(a[u].rc){
        dfss(a[u].rc,u);
        s[u]+=s[a[u].rc];
    }
    return;
}
void ddfs(int u,int fa){
    if(a[u].lc){
        f[a[u].lc]=f[u]-2*s[a[u].lc]+s[1];
        ddfs(a[u].lc,u);
    }
    if(a[u].rc){
        f[a[u].rc]=f[u]-2*s[a[u].rc]+s[1];
        ddfs(a[u].rc,u);
    }
}
int main(){
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;++i) read(a[i].p,a[i].lc,a[i].rc);
    dfs(1,0);
    dfss(1,-1);
    ddfs(1,-1);
    int ans=0x3f3f3f3f;
    for(int i=1;i&lt;=n;++i)
        ans=min(ans,f[i]);
    cout&lt;&lt;ans&lt;&lt;endl;
    return 0;
}
</code></pre>
<h2 id="noip2018-提高组赛道修建">「NOIP2018 提高组」赛道修建</h2>
<h4 id="题目描述-4">题目描述</h4>
<p>C 城将要举办一系列的赛车比赛。在比赛前，需要在城内修建 m 条赛道。</p>
<p>C 城一共有 n 个路口，这些路口编号为 1,2,…,n，有 n−1条适合于修建赛道的双向通行的道路，每条道路连接着两个路口。其中，第 i 条道路连接的两个路口编号为 ai 和 bi，该道路的长度为 li。借助这 n−1 条道路，从任何一个路口出发都能到达其他所有的路口。</p>
<p>一条赛道是一组互不相同的道路 e1,e2,…,ek，满足可以从某个路口出发，依次经过 道路 e1,e2,…,ek（每条道路经过一次，不允许调头）到达另一个路口。一条赛道的长度等于经过的各道路的长度之和。为保证安全，要求每条道路至多被一条赛道经过。</p>
<p>目前赛道修建的方案尚未确定。你的任务是设计一种赛道修建的方案，使得修建的 m 条赛道中长度最小的赛道长度最大（即 m 条赛道中最短赛道的长度尽可能大）</p>
<h4 id="输入格式-4">输入格式</h4>
<p>第一行包含两个由空格分隔的正整数 n,m，分别表示路口数及需要修建的 赛道数。<br>
接下来 n−1 行，第 i 行包含三个正整数 ai,bi,li，表示第 i 条适合于修建赛道的道 路连接的两个路口编号及道路长度。保证任意两个路口均可通过这 n−1 条道路相互到达。每行中相邻两数之间均由一个空格分隔。</p>
<h4 id="输出格式-4">输出格式</h4>
<p>输出共一行，包含一个整数，表示长度最小的赛道长度的最大值。</p>
<h4 id="数据范围与提示-2">数据范围与提示</h4>
<p><img src="https://jsoi.jzhx.net/file/20200312030614_20200312.png" alt="" loading="lazy"><br>
其中，“分支不超过 3”的含义为：每个路口至多有 3 条道路与其相连。 对于所有的数据， <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>50</mn><mo separator="true">,</mo><mn>000</mn><mi mathvariant="normal">，</mi><mn>1</mn><mo>≤</mo><mi>m</mi><mo>≤</mo><mi>n</mi><mi mathvariant="normal">−</mi><mn>1</mn><mi mathvariant="normal">，</mi><mn>1</mn><mo>≤</mo><mi>a</mi><mi>i</mi><mo separator="true">,</mo><mi>b</mi><mi>i</mi><mo>≤</mo><mi>n</mi><mi mathvariant="normal">，</mi><mn>1</mn><mo>≤</mo><mi>l</mi><mi>i</mi><mo>≤</mo><mn>10</mn><mo separator="true">,</mo><mn>000</mn><mi mathvariant="normal">。</mi></mrow><annotation encoding="application/x-tex">2≤n≤50,000， 1≤m≤n−1， 1≤ai,bi≤n， 1≤li≤10,000。</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">5</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord cjk_fallback">，</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mord">−</span><span class="mord">1</span><span class="mord cjk_fallback">，</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mord cjk_fallback">，</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord cjk_fallback">。</span></span></span></span></p>
<h4 id="输入样例-3">输入样例</h4>
<p>7 1<br>
1 2 10<br>
1 3 5<br>
2 4 9<br>
2 5 8<br>
3 6 6<br>
3 7 7</p>
<h4 id="输出样例-3">输出样例</h4>
<p>31</p>
<h4 id="思路-4">思路</h4>
<p>说实话，这题太适合我了，是二分+树上dp的好题。</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><menclose notation="horizontalstrike"><mrow><mi mathvariant="normal">如</mi><mi mathvariant="normal">果</mi><mi mathvariant="normal">这</mi><mi mathvariant="normal">题</mi><mi mathvariant="normal">能</mi><mi mathvariant="normal">是</mi><mn>2021</mn><mi>c</mi><mi>s</mi><mi>p</mi><mo>−</mo><mi>s</mi><mi mathvariant="normal">最</mi><mi mathvariant="normal">后</mi><mi mathvariant="normal">一</mi><mi mathvariant="normal">题</mi><mi mathvariant="normal">我</mi><mi mathvariant="normal">直</mi><mi mathvariant="normal">接</mi><mi mathvariant="normal">起</mi><mi mathvariant="normal">飞</mi></mrow></menclose></mrow><annotation encoding="application/x-tex">\sout{如果这题能是2021csp-s最后一题我直接起飞}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6444400000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">如</span><span class="mord cjk_fallback">果</span><span class="mord cjk_fallback">这</span><span class="mord cjk_fallback">题</span><span class="mord cjk_fallback">能</span><span class="mord cjk_fallback">是</span><span class="mord">2</span><span class="mord">0</span><span class="mord">2</span><span class="mord">1</span><span class="mord mathdefault">c</span><span class="mord mathdefault">s</span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">s</span><span class="mord cjk_fallback">最</span><span class="mord cjk_fallback">后</span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">题</span><span class="mord cjk_fallback">我</span><span class="mord cjk_fallback">直</span><span class="mord cjk_fallback">接</span><span class="mord cjk_fallback">起</span><span class="mord cjk_fallback">飞</span></span></span><span style="top:-3.2155em;"><span class="pstrut" style="height:3em;"></span><span class="stretchy sout"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span></span></span></p>
<p>不多说，首先看到要求的答案竟然是最小赛道长度的最大值，直接二分答案。将答案变为了判断性问题。</p>
<p>我的left和right都是闭区间，是从left到right都可以成功，我认为这样理解更为简单。</p>
<p>可以先去看那个只有3个分支的，那个是正解的弱化数据。<br>
对于三个分支，我现在就只可能有父亲节点，双儿子节点，对于每一条路径，对答案的贡献最多是1，然后我只需要查看一下两个节点的最长链加起来是不是大于了我现在要判断的答案。</p>
<p>题目还是很水的。</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define pb push_back
using namespace std;
template &lt;typename T&gt;inline void read(T&amp; t){
    t=0; register char ch=getchar();
    while(!('0'&lt;=ch&amp;&amp;ch&lt;='9')){if(ch=='-') t=-1;ch=getchar();}
    while(('0'&lt;=ch&amp;&amp;ch&lt;='9')){t=((t&lt;&lt;1)+(t&lt;&lt;3))+ch-'0'; ch=getchar();}
}
template &lt;typename T,typename... Args&gt; inline void read(T&amp; t, Args&amp;... args){
    read(t);read(args...);
}
template &lt;typename T&gt;inline void write(T x){
    if(x&lt;0) putchar('-'),x=~(x-1); int s[40],top=0;
    while(x) s[++top]=x%10,x/=10; if(!top) s[++top]=0;
    while(top) putchar(s[top--]+'0');
}
int n,m;
struct Edge{
    int to,nxt,w;
}e[114514];
vector&lt;pair&lt;int,int&gt; &gt;a[114514];
int s,cnt,pos;
int h[114514];
int f[114514];
void add(int u,int v,int w){
    e[++pos].to=v;
    e[pos].w=w;
    e[pos].nxt=h[u];
    h[u]=pos;
}
void dfs(int u,int fa,int pos){
    multiset&lt;int&gt;se;
    for(int i=h[u];i;i=e[i].nxt){
        int v=e[i].to,w=e[i].w;
        if(v==fa) continue;
        dfs(v,u,pos);
        if(f[v]+w&gt;=pos){
            cnt++;
            continue;
        }
        se.insert(f[v]+w);
    }
    while(!se.empty()){
        multiset&lt;int&gt;::iterator q=se.begin();
        se.erase(q);
        multiset&lt;int&gt;::iterator p=se.lower_bound(pos-*q);
        if(p!=se.end()){
            cnt++;
            se.erase(p);
        }else f[u]=max(f[u],*q);
    }
}
bool check(int x){
    memset(f,0,sizeof(f));
    cnt=0;
    dfs(1,-1,x);
    if(cnt&gt;=m) return 1;
    else return 0;
}
int main(){
    cin&gt;&gt;n&gt;&gt;m;
    for(int i=1;i&lt;n;++i){
        int x,y,w;
        read(x,y,w);
        s+=w;
        add(x,y,w);
        add(y,x,w);
    }
    int left=1,right=s/m+1;
    //left到right都可以
    while(left&lt;right){
        int mid=(left+right+1)&gt;&gt;1;
        if(check(mid)) left=mid;
        else right=mid-1;
    }
    cout&lt;&lt;left&lt;&lt;endl;
    return 0;
}
//19+12 31 
</code></pre>
<p>这里可以不用领接表，但是我害怕还是写<span class="katex"><span class="katex-mathml"><math><semantics><mrow><menclose notation="horizontalstrike"><mi mathvariant="normal">抄</mi></menclose></mrow><annotation encoding="application/x-tex">\sout{抄}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.2555em;vertical-align:0em;"></span><span class="mord"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.2555em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">抄</span></span></span><span style="top:-3.2155em;"><span class="pstrut" style="height:3em;"></span><span class="stretchy sout"></span></span></span></span></span></span></span></span></span>了一个。</p>
<p>完结撒花！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[对于数独问题的专题探究]]></title>
        <id>https://mercurycity.github.io/post/dui-yu-shu-du-wen-ti-de-zhuan-ti-tan-jiu/</id>
        <link href="https://mercurycity.github.io/post/dui-yu-shu-du-wen-ti-de-zhuan-ti-tan-jiu/">
        </link>
        <updated>2021-07-08T06:17:37.000Z</updated>
        <content type="html"><![CDATA[<p>最近研究了一下数独之类的问题（其实就两个）。总结一下：</p>
<p>数独，因为其较为复杂的相互关系被视为一种脑力工作。如果要去用计算机解决这个问题，则被看做一种暴力问题。</p>
<p>对于这些相互关系，我们可以用若干个二维数组去存储。</p>
<p>比如说P1784 数独，这一题，我们只需要用一个数组 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>n</mi><mi>u</mi><mi>m</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">h[i][num]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mclose">]</span></span></span></span> 去表示第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 行可否放 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">num</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span></span></span></span> 数字，用一个数组 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>n</mi><mi>u</mi><mi>m</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">l[i][num]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mclose">]</span></span></span></span> 去表示第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 列可否放 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">num</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span></span></span></span> 数字，然后再用一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>n</mi><mi>u</mi><mi>m</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">g[i][num]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mclose">]</span></span></span></span> 来表示第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 个九宫格中，可不可以放 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">num</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span></span></span></span>数字。</p>
<p>其实，在没看题解之前，我是用的一个三维数组描述可否放置的关系的，我是用的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>[</mo><mi>n</mi><mi>u</mi><mi>m</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">b[i][j][num]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mclose">]</span></span></span></span> 来表示在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(i,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span> 这个位置上，可不可以放置 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">num</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span></span></span></span> 的。这种方法为什么不好。仔细思考后会发现，一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>[</mo><mi>n</mi><mi>u</mi><mi>m</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">b[i][j][num]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mclose">]</span></span></span></span> 是关乎着它的行和列的，所以说，有很多地方可以更改这个数据，当我回溯的时候我并不知道这一个是我更改过的吗，所以这种方法并不是很好。同时，这种方法对于九宫格的逐一打标记是比较繁琐的。</p>
<p>好的，讲完了理论部分，那么开始实践部分吧。</p>
<p>先从一道黄题开始。<a href="https://www.luogu.com.cn/problem/P1784">题目传送门</a><br>
直截了当，就是数独。</p>
<p>抱着侥幸的心态，没有写优化，直接上，结果AC了，其实这道题目并不是特别需要优化。</p>
<p>那好，直接上die码：</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define pb push_back
using namespace std;
template &lt;typename T&gt;inline void read(T&amp; t){
    t=0; register char ch=getchar();
    while(!('0'&lt;=ch&amp;&amp;ch&lt;='9')){if(ch=='-') t=-1;ch=getchar();}
    while(('0'&lt;=ch&amp;&amp;ch&lt;='9')){t=((t&lt;&lt;1)+(t&lt;&lt;3))+ch-'0'; ch=getchar();}
}
template &lt;typename T,typename... Args&gt; inline void read(T&amp; t, Args&amp;... args){
    read(t);read(args...);
}
template &lt;typename T&gt;inline void write(T x){
    if(x&lt;0) putchar('-'),x=~(x-1); int s[40],top=0;
    while(x) s[++top]=x%10,x/=10; if(!top) s[++top]=0;
    while(top) putchar(s[top--]+'0');
}
const int n=9;
int h[11][11],l[11][11],g[11][11],a[11][11];
inline int gg(int x,int y){
    return (x-1)/3*3+(y-1)/3+1;
}
void Print(){
    for(int i=1;i&lt;=n;++i){
        for(int j=1;j&lt;=n;++j)
            cout&lt;&lt;a[i][j]&lt;&lt;' ';
        cout&lt;&lt;endl;
    }
    exit(0);
}
void dfs(int x,int y){
    if(x&gt;n) dfs(1,y+1);
    if(y&gt;n){
        Print();
        exit(0);
    }
    if(a[x][y]){
        dfs(x+1,y);
        return;
    }
    for(int num=1;num&lt;=9;++num){
        if(h[x][num]&amp;&amp;l[y][num]&amp;&amp;g[gg(x,y)][num]){
            a[x][y]=num;
            h[x][num]=l[y][num]=g[gg(x,y)][num]=0;
            dfs(x+1,y);
            h[x][num]=l[y][num]=g[gg(x,y)][num]=1;
            a[x][y]=0;
        }
    }
}
int main(){
    memset(h,1,sizeof(h));
    memset(l,1,sizeof(l));
    memset(g,1,sizeof(g));
    for(int i=1;i&lt;=n;++i)
        for(int j=1;j&lt;=n;++j){
            cin&gt;&gt;a[i][j];
            if(a[i][j]!=0) h[i][a[i][j]]=l[j][a[i][j]]=g[gg(i,j)][a[i][j]]=0;
        }
    dfs(1,1);
    return 0;
}
//(x-1)/3*3+(y-1)/3+1
</code></pre>
<p>这个题目只要求搜到满足条件的唯一一个解就ok了，所以时间复杂度不是那么假。在中途就可能终止程序。<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>79</mn><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">79ms</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">7</span><span class="mord">9</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span></span></span></span> 其实很快了。</p>
<p>根据这个思路，顺着出题者的<span class='katex-error' title='ParseError: KaTeX parse error: Undefined control sequence: \fout at position 1: \̲f̲o̲u̲t̲{尿性}'>\fout{尿性}</span>思路，我们可以稍微调整一下搜索顺序，原来是对于每一位的思考，从1到9，那么我偏偏反着来，从9到1。</p>
<p>其实数据随机根本优化不了多少，但是这题优化的比较多吧。一个点优化了50ms<br>
总计 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>21</mn><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">21ms</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">1</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span></span></span></span> 。</p>
<p>好，现在上第二题，循序渐进，第二题来个蓝题：<a href="https://www.luogu.com.cn/problem/P1074">题目传送门</a><br>
其实感觉难度虚高。</p>
<p>对于这一题，我们其实只需要搜完，然后按照答案的方式取一个最大值。但是剪枝，以及搜索顺序的思考要考虑完整。这题感觉没有最优性剪枝等，所以主要是从搜索顺序上优化。</p>
<h4 id="无优化">无优化</h4>
<p>这一种方法简单，就是上一题的加权求答案版本。但是过了这一题（非常勉强）。<br>
不多说，直接上die码：、</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define pb push_back
using namespace std;
template &lt;typename T&gt;inline void read(T&amp; t){
    t=0; register char ch=getchar();
    while(!('0'&lt;=ch&amp;&amp;ch&lt;='9')){if(ch=='-') t=-1;ch=getchar();}
    while(('0'&lt;=ch&amp;&amp;ch&lt;='9')){t=((t&lt;&lt;1)+(t&lt;&lt;3))+ch-'0'; ch=getchar();}
}
template &lt;typename T,typename... Args&gt; inline void read(T&amp; t, Args&amp;... args){
    read(t);read(args...);
}
template &lt;typename T&gt;inline void write(T x){
    if(x&lt;0) putchar('-'),x=~(x-1); int s[40],top=0;
    while(x) s[++top]=x%10,x/=10; if(!top) s[++top]=0;
    while(top) putchar(s[top--]+'0');
}
inline int gg(int x,int y){
    return (x-1)/3*3+(y-1)/3+1;
}
bool h[11][11],l[11][11],g[11][11];
vector&lt;int&gt;p;
const int n=9;
int a[11][11];
int ans=0;
int xs[11][11]={{0,0,0,0,0,0,0,0,0,0},{0,6,6,6,6,6,6,6,6,6},{0,6,7,7,7,7,7,7,7,6},{0,6,7,8,8,8,8,8,7,6},{0,6,7,8,9,9,9,8,7,6},{0,6,7,8,9,10,9,8,7,6},{0,6,7,8,9,9,9,8,7,6},{0,6,7,8,8,8,8,8,7,6},{0,6,7,7,7,7,7,7,7,6},{0,6,6,6,6,6,6,6,6,6}};
void dfs(int x,int y,int score){
    if(x&gt;n) dfs(1,y+1,score);
    if(y&gt;n){
        ans=max(score,ans);
        return;
    }
    if(a[x][y]){dfs(x+1,y,score+a[x][y]*xs[x][y]);
return;}
    for(register int num=1;num&lt;=9;++num)
        if(h[x][num]&amp;&amp;l[y][num]&amp;&amp;g[gg(x,y)][num]){
            //说明这一位可以放上num
            h[x][num]=l[y][num]=g[gg(x,y)][num]=0;
            dfs(x+1,y,score+num*xs[x][y]);
            h[x][num]=l[y][num]=g[gg(x,y)][num]=1;
        }
}
int main(){
    memset(h,1,sizeof(h));
    memset(l,1,sizeof(l));
    memset(g,1,sizeof(g));
    for(register int i=1;i&lt;=n;++i)
        for(register int j=1;j&lt;=n;++j){
            read(a[i][j]);
            h[i][a[i][j]]=l[j][a[i][j]]=g[gg(i,j)][a[i][j]]=(a[i][j]==0);
        }
    dfs(1,1,0);
    cout&lt;&lt;((ans==0)?-1:ans)&lt;&lt;endl;
    return 0;
}
//(x-1)/3*3+(y-1)/3+1
</code></pre>
<p>这一种方法跑的非常慢，差一点点TLE <a href="https://www.luogu.com.cn/record/52609199">测评记录</a></p>
<h4 id="way1-行优化">Way1 行优化</h4>
<p>这一种有很多思考的点。</p>
<p>为什么这种优化会优化。很多谷民都提出了这个问题，经过一段时间的研究后，我得出了原因所在。<br>
假如说，现在我只要填一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn><mo>×</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">3×3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span> 的数独，如下图。<br>
<img src="https://z3.ax1x.com/2021/07/08/RLxQv4.png" alt="" loading="lazy"></p>
<p>好的，现在这个图，肯定最少数字的点肯定是第一行这个，如果我现在填上了它，第二行第二个的也可以确定下来。所以说，这种思路是比较快的。<br>
主要的误区在于要从填写这个数独的角度，而不是分数的角度考虑。</p>
<p>所以说，这种算法是比较快的（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>966</mn><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">966ms</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">9</span><span class="mord">6</span><span class="mord">6</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span></span></span></span>）。</p>
<p>值得一提的是，我同样用了上面一题的方法（改变搜索顺序）尝试，其实是变慢了( <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>977</mn><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">977ms</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">9</span><span class="mord">7</span><span class="mord">7</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span></span></span></span> )，按道理不会变慢，可能是评测姬波动。但是，其实全部搜索结束的时候，搜索顺序的变化是没有用的。</p>
<p>下面上die码：</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define pb push_back
using namespace std;
template &lt;typename T&gt;inline void read(T&amp; t){
    t=0; register char ch=getchar();
    while(!('0'&lt;=ch&amp;&amp;ch&lt;='9')){if(ch=='-') t=-1;ch=getchar();}
    while(('0'&lt;=ch&amp;&amp;ch&lt;='9')){t=((t&lt;&lt;1)+(t&lt;&lt;3))+ch-'0'; ch=getchar();}
}
template &lt;typename T,typename... Args&gt; inline void read(T&amp; t, Args&amp;... args){
    read(t);read(args...);
}
template &lt;typename T&gt;inline void write(T x){
    if(x&lt;0) putchar('-'),x=~(x-1); int s[40],top=0;
    while(x) s[++top]=x%10,x/=10; if(!top) s[++top]=0;
    while(top) putchar(s[top--]+'0');
}
inline int gg(int x,int y){
    return (x-1)/3*3+(y-1)/3+1;
}
struct Info{
    int x,s;
    bool operator &lt;(const Info &amp;info) const {
        return s&lt;info.s;
    }
};
bool h[11][11],l[11][11],g[11][11];
const int n=9;
int a[11][11];
vector&lt;Info&gt;p;
int ans=0;
int xs[11][11]={{0,0,0,0,0,0,0,0,0,0},{0,6,6,6,6,6,6,6,6,6},{0,6,7,7,7,7,7,7,7,6},{0,6,7,8,8,8,8,8,7,6},{0,6,7,8,9,9,9,8,7,6},{0,6,7,8,9,10,9,8,7,6},{0,6,7,8,9,9,9,8,7,6},{0,6,7,8,8,8,8,8,7,6},{0,6,7,7,7,7,7,7,7,6},{0,6,6,6,6,6,6,6,6,6}};
void dfs(int x,int y,int score,int dep){
    if(y&gt;n) dfs(p[dep+1].x,1,score,dep+1);
    if(dep==9){
        ans=max(ans,score);
        return;
    }
    if(a[x][y]){
        dfs(x,y+1,score+a[x][y]*xs[x][y],dep);
        return;
    }
    for(register int num=1;num&lt;=9;++num)
        if(h[x][num]&amp;&amp;l[y][num]&amp;&amp;g[gg(x,y)][num]){
            //说明这一位可以放上num
            h[x][num]=0;l[y][num]=0;g[gg(x,y)][num]=0;
            dfs(x,y+1,score+num*xs[x][y],dep);
            h[x][num]=1;l[y][num]=1;g[gg(x,y)][num]=1;
        }
}
int main(){
    memset(h,1,sizeof(h));
    memset(l,1,sizeof(l));
    memset(g,1,sizeof(g));
    for(register int i=1;i&lt;=n;++i)
        for(register int j=1;j&lt;=n;++j){
            read(a[i][j]);
            h[i][a[i][j]]=l[j][a[i][j]]=g[gg(i,j)][a[i][j]]=(a[i][j]==0);
        }
    for(register int i=1;i&lt;=n;++i){
        int sum=0;
        for(register int j=1;j&lt;=n;++j){
            for(register int k=1;k&lt;=n;++k)
                if(h[i][k]&amp;&amp;l[j][k]&amp;&amp;g[gg(i,j)][k]) ++sum;
        }
        p.push_back({i,sum});
    }
    sort(p.begin(),p.end());
    dfs(p[0].x,1,0,0);
    cout&lt;&lt;((ans==0)?-1:ans)&lt;&lt;endl;
    return 0;
}
//(x-1)/3*3+(y-1)/3+1
</code></pre>
<h4 id="way2从输入的时候填写方法少的地方开始搜索">Way2：从输入的时候填写方法少的地方开始搜索</h4>
<p><strong>注意，这种方法并不是正解，TLE90pts</strong><br>
这种方法很假，这里讲一下，为什么会假。首先，对于这种方法，并没有动态性，就是说，我一开始填写方法少，并不代表后来填写的方法会少，所以说这种方法并不是很好。</p>
<p>并且，这种方式其实和随机搜索是差不多的，还加上了一开始处理的常数，其实是一种错解。</p>
<p>这里出示die码，仅供思考。</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define pb push_back
using namespace std;
template &lt;typename T&gt;inline void read(T&amp; t){
    t=0; register char ch=getchar();
    while(!('0'&lt;=ch&amp;&amp;ch&lt;='9')){if(ch=='-') t=-1;ch=getchar();}
    while(('0'&lt;=ch&amp;&amp;ch&lt;='9')){t=((t&lt;&lt;1)+(t&lt;&lt;3))+ch-'0'; ch=getchar();}
}
template &lt;typename T,typename... Args&gt; inline void read(T&amp; t, Args&amp;... args){
    read(t);read(args...);
}
template &lt;typename T&gt;inline void write(T x){
    if(x&lt;0) putchar('-'),x=~(x-1); int s[40],top=0;
    while(x) s[++top]=x%10,x/=10; if(!top) s[++top]=0;
    while(top) putchar(s[top--]+'0');
}
inline int gg(int x,int y){
    return (x-1)/3*3+(y-1)/3+1;
}
struct Info{
    int x,y,s;
    bool operator &lt;(const Info &amp;info) const {
        return s&lt;info.s;
    }
};
bool h[11][11],l[11][11],g[11][11];
const int n=9;
int a[11][11];
vector&lt;Info&gt;p;
int ans=0;
int xs[11][11]={{0,0,0,0,0,0,0,0,0,0},{0,6,6,6,6,6,6,6,6,6},{0,6,7,7,7,7,7,7,7,6},{0,6,7,8,8,8,8,8,7,6},{0,6,7,8,9,9,9,8,7,6},{0,6,7,8,9,10,9,8,7,6},{0,6,7,8,9,9,9,8,7,6},{0,6,7,8,8,8,8,8,7,6},{0,6,7,7,7,7,7,7,7,6},{0,6,6,6,6,6,6,6,6,6}};
void dfs(int score,int dep){
    if(dep==81){
        ans=max(ans,score);
        return;
    }
    int x=p[dep].x,y=p[dep].y;
    if(a[x][y]){dfs(score+a[x][y]*xs[x][y],dep+1);
return;}
    for(register int num=1;num&lt;=9;++num)
        if(h[x][num]&amp;&amp;l[y][num]&amp;&amp;g[gg(x,y)][num]){
            //说明这一位可以放上num
            h[x][num]=0;l[y][num]=0;g[gg(x,y)][num]=0;
            dfs(score+num*xs[x][y],dep+1);
            h[x][num]=1;l[y][num]=1;g[gg(x,y)][num]=1;
        }
}
int main(){
    memset(h,1,sizeof(h));
    memset(l,1,sizeof(l));
    memset(g,1,sizeof(g));
    for(register int i=1;i&lt;=n;++i)
        for(register int j=1;j&lt;=n;++j){
            read(a[i][j]);
            h[i][a[i][j]]=l[j][a[i][j]]=g[gg(i,j)][a[i][j]]=(a[i][j]==0);
        }
    for(register int i=1;i&lt;=n;++i){
        for(register int j=1;j&lt;=n;++j){
            int sum=0;
            for(register int k=1;k&lt;=n;++k)
                if(h[i][k]&amp;&amp;l[j][k]&amp;&amp;g[gg(i,j)][k]) ++sum;
            p.push_back({i,j,sum});
        }
    }
    sort(p.begin(),p.end());
    dfs(0,0);
    cout&lt;&lt;((ans==0)?-1:ans)&lt;&lt;endl;
    return 0;
}
//(x-1)/3*3+(y-1)/3+1
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[人生第一道交互题！洛谷P1947 猜数 个人题解]]></title>
        <id>https://mercurycity.github.io/post/ren-sheng-di-yi-dao-jiao-hu-ti-luo-gu-p1947-cai-shu-ge-ren-ti-jie/</id>
        <link href="https://mercurycity.github.io/post/ren-sheng-di-yi-dao-jiao-hu-ti-luo-gu-p1947-cai-shu-ge-ren-ti-jie/">
        </link>
        <updated>2021-07-05T13:52:42.000Z</updated>
        <content type="html"><![CDATA[<h2 id="洛谷p1947-猜数">洛谷P1947 猜数</h2>
<h3 id="题目背景">题目背景</h3>
<p>这是一道交互题。</p>
<h3 id="题目描述">题目描述</h3>
<p>珂愛给了你一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mn>1</mn><mo separator="true">,</mo><mi>n</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[1,n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">]</span></span></span></span> 之间的整数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> ，你每次可以询问一个整数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> ，然后珂愛会告诉你 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 的大小关系。</p>
<p>你需要用尽可能少的次数猜出珂愛想的数。</p>
<p>你需要实现一个函数 int Chtholly(int n,int c)，这个函数的作用是在不超过 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span> 次询问中猜对 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mn>1</mn><mo separator="true">,</mo><mi>n</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[1,n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">]</span></span></span></span> 中的一个数，返回值为你最终确定的数。</p>
<p>你可以调用交互库中一个叫做 Seniorious 的函数，其原型为 int Seniorious(int x)，返回值为：</p>
<p>若 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>&lt;</mo><mi>x</mi><mi>k</mi><mo>&lt;</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">k\lt xk&lt;x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">x</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>，则返回 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 。<br>
若<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>&gt;</mo><mi>x</mi><mi>k</mi><mo>&gt;</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">k\gt xk&gt;x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">x</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>，则返回 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">−</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">−1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span> 。<br>
若 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>=</mo><mi>x</mi><mi>k</mi><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">k=xk=x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>，则返回 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 。<br>
你调用 Seniorious 函数的次数不超过 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span> 才能得到这个点的分数，否则这个点为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 分。有关该函数的调用请参考【说明/提示】部分。</p>
<p>由于珂愛只会写 C++ 语言的交互库，所以你只能使用 C++ 语言（包括 C++，C++11，C++14，C++17）来解决本题。</p>
<h3 id="输入格式">输入格式</h3>
<p>样例输入中三个数分别为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 。这些数据你都无法读取。</p>
<h3 id="输出格式">输出格式</h3>
<p>样例输出中第一个数是你猜的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>，第二个数是你调用 Seniorious 函数的次数。这些数据你不必输出。</p>
<h3 id="输入输出样例">输入输出样例</h3>
<h4 id="输入">输入</h4>
<p>5 5 3</p>
<h4 id="输出">输出</h4>
<p>3 0</p>
<h3 id="说明提示">说明/提示</h3>
<h4 id="样例解释">样例解释</h4>
<p>你要猜的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span> 。</p>
<p>由于你和珂愛心灵相通，所以在没有调用 Seniorious 的情况下就猜出来了。</p>
<h4 id="数据规模与约定">数据规模与约定</h4>
<p>对于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>30</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">30\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">3</span><span class="mord">0</span><span class="mord">%</span></span></span></span> 的数据，保证 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mo>=</mo><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">c=n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。<br>
对于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>100</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">100\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">%</span></span></span></span> 的数据，保证 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup></mrow><annotation encoding="application/x-tex">2\leq n\leq 10^6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>min</mi><mo>⁡</mo><mo>(</mo><mn>20</mn><mo separator="true">,</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>)</mo><mo>≤</mo><mi>c</mi><mo>≤</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">\min(20,n-1)\leq c\leq n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">min</span><span class="mopen">(</span><span class="mord">2</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>。</p>
<h2 id="如何氵题">如何氵题</h2>
<p>首先，第一道交互题，我并没有选择IO交互，因为现在貌似所有大考都是grader交互呢。（虽然容易被草过去）</p>
<p>做了这个题目，第一个学会的是<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi><mi>x</mi><mi>t</mi><mi>e</mi><mi>r</mi><mi>n</mi><mi mathvariant="normal">&quot;</mi><mi>C</mi><mi mathvariant="normal">&quot;</mi></mrow><annotation encoding="application/x-tex">extern &quot;C&quot;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">n</span><span class="mord">&quot;</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord">&quot;</span></span></span></span>这个东西加在了一个函数的前面，那么说明这个函数是交互函数。<br>
并且，似乎这种题目就是让你写完一个函数，然后返回一个正确的值就ok了。<br>
在完成这个函数的同时，他会给你一些辅助函数，这些函数都是非常有用的（除非你当打CTF一样打OI）。</p>
<p>好的，这个程序我们一行一行分析，首先第一行。</p>
<pre><code class="language-cpp">extern &quot;C&quot; int Seniorious(int);
</code></pre>
<p>明显，声明一下这个是出题人给的函数，并且这个函数是出题人给的，不是我们完善的，只需要声明就OK了。</p>
<p>好，然后是需要我们完成的函数。</p>
<pre><code class="language-cpp">extern &quot;C&quot; int Chtholly(int n,int c){
    int left=1,right=n;
    while(left&lt;right){
        int mid=(left+right)/2;
        int pos=Seniorious(mid);
        if(pos==0){
            return mid;
            break;
        }
        if(pos==1) right=mid-1;
        else left=mid+1;
    }
    return left;
}
</code></pre>
<p>下一次开二分搜索的坑。</p>
<p>这里不着重讲二分搜索，主要讲交互题的格式之类的。</p>
<p>首先，声明一下这个函数叫Chtholly。<span class="katex"><span class="katex-mathml"><math><semantics><mrow><menclose notation="horizontalstrike"><mrow><mi mathvariant="normal">我</mi><mi mathvariant="normal">永</mi><mi mathvariant="normal">远</mi><mi mathvariant="normal">爱</mi><mi mathvariant="normal">珂</mi><mi mathvariant="normal">朵</mi><mi mathvariant="normal">莉</mi></mrow></menclose></mrow><annotation encoding="application/x-tex">\sout{我永远爱珂朵莉}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.2555em;vertical-align:0em;"></span><span class="mord"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.2555em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">我</span><span class="mord cjk_fallback">永</span><span class="mord cjk_fallback">远</span><span class="mord cjk_fallback">爱</span><span class="mord cjk_fallback">珂</span><span class="mord cjk_fallback">朵</span><span class="mord cjk_fallback">莉</span></span></span><span style="top:-3.2155em;"><span class="pstrut" style="height:3em;"></span><span class="stretchy sout"></span></span></span></span></span></span></span></span></span> 然后呢，先定义一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo>=</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">left=1,right=n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>，表示一个区间。这个区间里应该存的是可以满足条件的数的整个数组。</p>
<p>好，然后这一步非常关键</p>
<pre><code class="language-cpp">    int pos=Seniorious(mid);
</code></pre>
<p>这一步就是说明，我现在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>o</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">pos</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span></span></span></span>来去访问一下你的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>e</mi><mi>n</mi><mi>i</mi><mi>o</mi><mi>r</mi><mi>i</mi><mi>o</mi><mi>u</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">Seniorious</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault">u</span><span class="mord mathdefault">s</span></span></span></span>函数，然后返回一个值，交互交互，这就是向评测姬提问的过程。</p>
<p>然后就是朴素二分的写法，这里不多赘述。</p>
<pre><code class="language-cpp">    return left;
</code></pre>
<p>最后要求的答案是找到的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>，显然，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>如果在外部的话，那这个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>=</mo><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mo>=</mo><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">k=left=right</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span></span></span></span>，随便返回一个都ok了。</p>
<p>完结撒花！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2021 January Contest Bronze 题解]]></title>
        <id>https://mercurycity.github.io/post/2021-january-contest-bronze-ti-jie/</id>
        <link href="https://mercurycity.github.io/post/2021-january-contest-bronze-ti-jie/">
        </link>
        <updated>2021-07-04T10:57:32.000Z</updated>
        <content type="html"><![CDATA[<h2 id="t1-uddered-but-not-herd">T1 Uddered but not Herd</h2>
<h4 id="题面描述">题面描述</h4>
<p>一个鲜为人知的事实是，奶牛拥有自己的文字：「牛文」。牛文由 26 个字母 'a' 到 'z' 组成，但是当奶牛说牛文时，可能与我们所熟悉的 'abcdefghijklmnopqrstuvwxyz' 不同，她会按某种特定的顺序排列字母。<br>
为了打发时间，奶牛 Bessie 在反复哼唱牛文字母歌，而 Farmer John 好奇她唱了多少遍。</p>
<p>给定一个小写字母组成的字符串，为 Farmer John 听到 Bessie 唱的字母，计算 Bessie 至少唱了几遍完整的牛文字母歌，使得 Farmer John 能够听到给定的字符串。Farmer John 并不始终注意 Bessie 所唱的内容，所以他可能会漏听 Bessie 唱过的一些字母。给定的字符串仅包含他记得他所听到的字母。</p>
<h4 id="输入格式从终端标准输入读入">输入格式（从终端/标准输入读入）：</h4>
<p>输入的第一行包含 26 个小写字母 'a' 到 'z' 的牛文字母表顺序。下一行包含一个小写字母组成的字符串，为 Farmer John 听到 Bessie 唱的字母。字符串的长度不小于 1 且不大于 1000。</p>
<h4 id="输出格式输出至终端标准输出">输出格式（输出至终端/标准输出）：</h4>
<p>输出 Bessie 所唱的完整的牛文字母歌的最小次数。</p>
<h4 id="输入样例">输入样例：</h4>
<p>abcdefghijklmnopqrstuvwxyz<br>
mood</p>
<h4 id="输出样例">输出样例：</h4>
<p>3</p>
<h4 id="样例解释">样例解释</h4>
<p>在这个样例中，牛文字母表与日常的字母表的排列一致。<br>
Bessie 至少唱了三遍牛文字母歌。有可能 Bessie 只唱了三遍牛文字母歌，而 Farmer John 听到了以下被标记为大写的字母。<br>
abcdefghijklMnOpqrstuvwxyz<br>
abcdefghijklmnOpqrstuvwxyz<br>
abcDefghijklmnopqrstuvwxyz</p>
<h4 id="测试点性质">测试点性质：</h4>
<p>测试点 2-5 中，牛文字母表与日常的字母表相同。<br>
测试点 6-10 没有额外限制。</p>
<p>试图直接用一个公式直接写出此题答案，罢了，根本不会写。</p>
<p>好的，那么这题的思路非常的显然，就是说，如果我现在这一位的字符对于前一位字符来说在字母表的较前位置，这显然是不合法的。同时，须要注意的是，如果现在又连续两位的字符，那么肯定是唱了两遍歌的毋庸置疑。</p>
<p>蒟蒻die码：</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define pb push_back
using namespace std;
template &lt;typename T&gt;inline void read(T&amp; t){
    t=0; register char ch=getchar();
    while(!('0'&lt;=ch&amp;&amp;ch&lt;='9')){if(ch=='-') t=-1;ch=getchar();}
    while(('0'&lt;=ch&amp;&amp;ch&lt;='9')){t=((t&lt;&lt;1)+(t&lt;&lt;3))+ch-'0'; ch=getchar();}
}
template &lt;typename T,typename... Args&gt; inline void read(T&amp; t, Args&amp;... args){
    read(t);read(args...);
}
template &lt;typename T&gt;inline void write(T x){
    if(x&lt;0) putchar('-'),x=~(x-1); int s[40],top=0;
    while(x) s[++top]=x%10,x/=10; if(!top) s[++top]=0;
    while(top) putchar(s[top--]+'0');
}
string st;
bool later(char ch1,char ch2){
    //写了一个函数来判断ch1是不是在ch2后
    //同时，如果ch1完全等于ch2时，这说明我读了两遍一个词，这直接累加答案
    if(ch1==ch2) return 1;
    for(int i=0;i&lt;st.size();++i){
        if(st[i]==ch1) return 0;
        if(st[i]==ch2) return 1;
    }
    return 0; //其实不会到这个时候了
}
int ans;
string st1;
int main(){
    cin&gt;&gt;st&gt;&gt;st1;
    char lch=st1[0];
    for(int i=1;i&lt;st1.size();++i){
        if(later(lch,st1[i])) ans++;
        lch=st1[i];
    }
    cout&lt;&lt;ans+1&lt;&lt;endl;
    return 0;
}
</code></pre>
<h2 id="t2-even-more-odd-photos">T2 Even More Odd Photos</h2>
<h4 id="题面描述-2">题面描述</h4>
<p>Farmer John 正再一次尝试给他的 N 头奶牛拍照（2≤N≤1000）。<br>
每头奶牛有一个范围在 1…100 之内的整数的「品种编号」。Farmer John 对他的照片有一个十分古怪的构思：他希望将所有的奶牛分为不相交的若干组（换句话说，将每头奶牛分到恰好一组中）并将这些组排成一行，使得第一组的奶牛的品种编号之和为偶数，第二组的编号之和为奇数，以此类推，奇偶交替。<br>
Farmer John 可以分成的最大组数是多少？</p>
<h4 id="输入格式从终端标准输入读入-2">输入格式（从终端/标准输入读入）：</h4>
<p>输入的第一行包含 N。下一行包含 N 个空格分隔的整数，为 N 头奶牛的品种编号。</p>
<h4 id="输出格式输出至终端标准输出-2">输出格式（输出至终端/标准输出）：</h4>
<p>输出 Farmer John 的照片中的最大组数。可以证明，至少存在一种符合要求的分组方案。</p>
<h4 id="输入样例1">输入样例1：</h4>
<p>7<br>
1 3 5 7 9 11 13</p>
<h4 id="输出样例1">输出样例1：</h4>
<p>3</p>
<h4 id="样例解释1">样例解释1</h4>
<p>在这个样例中，以下是一种分成最大组数三组的方案。将 1 和 3 分在第一组，5、7 和 9 分在第二组，11 和 13 分在第三组。</p>
<h4 id="输入样例2">输入样例2：</h4>
<p>7<br>
11 2 17 13 1 15 3</p>
<h4 id="输出样例2">输出样例2：</h4>
<p>5</p>
<h4 id="样例解释3">样例解释3：</h4>
<p>在这个样例中，以下是一种分成最大组数五组的方案。将 2 分在第一组，11 分在第二组，13 和 1 分在第三组，15 分在第四组，17 和 3 分在第五组。</p>
<h4 id="解题思路">解题思路：</h4>
<p>感觉就是一个大模拟，想了很久。详细内容不说了，见die码。附注，USACO给出的标准答案似乎die码复杂度比我的高：</p>
<p>算了，还是稍微讲一讲，避免未来又忘了这一题怎么做了。</p>
<p>首先的首先，会发现这一题其实数字大小没什么用，只是其奇偶性会改变很多。</p>
<p>ok首先，明显的一个贪心思路，就是说，如果我现在需要一个奇数，我肯定是上一个奇数，而不是上一个偶数加上一个奇数，因为明显，这个偶数可以放在后面一位来多创造一个价值。</p>
<p>根据这个思路，我现在先将偶数的数量和奇数的数量统计好。<br>
然后现在判断是偶数数量多还是奇数数量多。<br>
从简单开始，如果是偶数数量多，那么放偶数奇数偶数奇数，会发现放到最后一个奇数之后的那个偶数后，再多的偶数也只能叠加到前面去，创造不出一个新的奇数了，所以说这个答案比较简单，就是奇数数量*2+1。这是一个比较简单的情况。<br>
如果一样多，那么答案很显然就是两个数量加起来<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>n</mtext></mrow><annotation encoding="application/x-tex">\text{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord text"><span class="mord">n</span></span></span></span></span><br>
由简至繁，如果现在是奇数数量多。<br>
插一句题外话，为什么奇数数量多更加的复杂，其实很好理解，就是说，奇数数量多出来了，我两个奇数可以合成偶数，放一个奇数在别的地方会改变奇偶性，所以说明显是奇数数量多更加复杂。<br>
好，回归正题，如果是奇数数量多的时候呢。不妨把可以消耗的偶数全部消耗完毕（反正迟早也是必须的嘛。<br>
我现在的答案就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>n</mi><mi>s</mi><mo>×</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">ans\times 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>然后呢，我现在还剩奇数的个数减去偶数的个数个奇数（好像很绕）。<br>
假设我现在还剩<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>pos</mtext></mrow><annotation encoding="application/x-tex">\text{pos}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord text"><span class="mord">pos</span></span></span></span></span>个奇数，貌似是个找规律呢，打个表。</p>
<p>其实表格是有一个很好看的的，但是我不会写<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>LaTeX</mtext></mrow><annotation encoding="application/x-tex">\LaTeX</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.89883em;vertical-align:-0.2155em;"></span><span class="mord text"><span class="mord textrm">L</span><span class="mspace" style="margin-right:-0.36em;"></span><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.68333em;"><span style="top:-2.904999em;"><span class="pstrut" style="height:2.7em;"></span><span class="mord text"><span class="mord textrm sizing reset-size6 size3">A</span></span></span></span></span></span><span class="mspace" style="margin-right:-0.15em;"></span><span class="mord text"><span class="mord textrm">T</span><span class="mspace" style="margin-right:-0.1667em;"></span><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.46782999999999997em;"><span style="top:-2.7845em;"><span class="pstrut" style="height:3em;"></span><span class="mord text"><span class="mord textrm">E</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2155em;"><span></span></span></span></span><span class="mspace" style="margin-right:-0.125em;"></span><span class="mord textrm">X</span></span></span></span></span></span>，罢了罢了。</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>p</mi><mi>o</mi><mi>s</mi><mi mathvariant="normal">Δ</mi><mi>a</mi><mi>n</mi><mi>s</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>1</mn><mtext>  </mtext><mo>−</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>2</mn><mtext> </mtext><mspace width="1em"/><mtext>  </mtext><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>3</mn><mtext> </mtext><mspace width="1em"/><mtext>  </mtext><mn>2</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>4</mn><mtext> </mtext><mspace width="1em"/><mtext>  </mtext><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>5</mn><mtext> </mtext><mspace width="1em"/><mtext>  </mtext><mn>3</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>6</mn><mtext> </mtext><mspace width="1em"/><mtext>  </mtext><mn>4</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>7</mn><mtext> </mtext><mspace width="1em"/><mtext>  </mtext><mn>3</mn></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{matrix}
pos \Delta ans\\
1    \  \  -1\\
2   \ \quad\ \   1\\
3   \ \quad\  \  2\\
4   \ \quad\ \   1\\
5   \ \quad\ \   3\\
6   \ \quad\ \   4\\
7   \ \quad\ \   3\\
\end{matrix}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:9.600000000000001em;vertical-align:-4.55em;"></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:5.050000000000001em;"><span style="top:-7.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mord">Δ</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span></span></span><span style="top:-6.010000000000001em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mspace"> </span><span class="mspace"> </span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span></span></span><span style="top:-4.8100000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mspace"> </span><span class="mspace" style="margin-right:1em;"></span><span class="mspace"> </span><span class="mspace"> </span><span class="mord">1</span></span></span><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">3</span><span class="mspace"> </span><span class="mspace" style="margin-right:1em;"></span><span class="mspace"> </span><span class="mspace"> </span><span class="mord">2</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">4</span><span class="mspace"> </span><span class="mspace" style="margin-right:1em;"></span><span class="mspace"> </span><span class="mspace"> </span><span class="mord">1</span></span></span><span style="top:-1.2099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">5</span><span class="mspace"> </span><span class="mspace" style="margin-right:1em;"></span><span class="mspace"> </span><span class="mspace"> </span><span class="mord">3</span></span></span><span style="top:-0.00999999999999951em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">6</span><span class="mspace"> </span><span class="mspace" style="margin-right:1em;"></span><span class="mspace"> </span><span class="mspace"> </span><span class="mord">4</span></span></span><span style="top:1.1899999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">7</span><span class="mspace"> </span><span class="mspace" style="margin-right:1em;"></span><span class="mspace"> </span><span class="mspace"> </span><span class="mord">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:4.55em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p>好，现在不难发现规律，规律就不用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>LaTeX</mtext></mrow><annotation encoding="application/x-tex">\LaTeX</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.89883em;vertical-align:-0.2155em;"></span><span class="mord text"><span class="mord textrm">L</span><span class="mspace" style="margin-right:-0.36em;"></span><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.68333em;"><span style="top:-2.904999em;"><span class="pstrut" style="height:2.7em;"></span><span class="mord text"><span class="mord textrm sizing reset-size6 size3">A</span></span></span></span></span></span><span class="mspace" style="margin-right:-0.15em;"></span><span class="mord text"><span class="mord textrm">T</span><span class="mspace" style="margin-right:-0.1667em;"></span><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.46782999999999997em;"><span style="top:-2.7845em;"><span class="pstrut" style="height:3em;"></span><span class="mord text"><span class="mord textrm">E</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2155em;"><span></span></span></span></span><span class="mspace" style="margin-right:-0.125em;"></span><span class="mord textrm">X</span></span></span></span></span></span>写了</p>
<p>蒟蒻die码：</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define pb push_back
using namespace std;
template &lt;typename T&gt;inline void read(T&amp; t){
    t=0; register char ch=getchar();
    while(!('0'&lt;=ch&amp;&amp;ch&lt;='9')){if(ch=='-') t=-1;ch=getchar();}
    while(('0'&lt;=ch&amp;&amp;ch&lt;='9')){t=((t&lt;&lt;1)+(t&lt;&lt;3))+ch-'0'; ch=getchar();}
}
template &lt;typename T,typename... Args&gt; inline void read(T&amp; t, Args&amp;... args){
    read(t);read(args...);
}
template &lt;typename T&gt;inline void write(T x){
    if(x&lt;0) putchar('-'),x=~(x-1); int s[40],top=0;
    while(x) s[++top]=x%10,x/=10; if(!top) s[++top]=0;
    while(top) putchar(s[top--]+'0');
}
int n;
int odd,even,ans;
int main(){
    cin&gt;&gt;n;
    while(n--){
        int t;
        read(t);
        if(t%2==0) even++;
        else odd++;
    }
    if(odd==even){
        cout&lt;&lt;odd&lt;&lt;endl;
        return 0;
    }
    //好，现在知道了这个过程，就模拟它
    //现在要构造第一组是偶数，第二组是奇数，就一直这样，那么先看是偶数多还是奇数多
    if(odd&gt;even){
        //奇数多，答案先累加一下偶数
        ans=even*2;
        //要贡献even个奇数
        odd=odd-even;
        if(odd%3==1)
            cout&lt;&lt;(odd/3)*2-1+ans&lt;&lt;endl;
        else 
            if(odd%3==0)
                cout&lt;&lt;(odd/3)*2+ans&lt;&lt;endl;
            else
                cout&lt;&lt;(odd/3)*2+1+ans&lt;&lt;endl;
        return 0;
        //好，接下来一个应该是偶数然后是奇数
        //打个表看一看
        //还有一个就是说，如果现在还剩一个奇数，但是这一位要求一个偶数，那很难办，放在哪里都会打破平衡他本来的奇偶性，那么该怎么办呢。
        //奇数，那么想到的唯一一个办法就是少组两个，现在手里就肯定还会剩
        /*
        少组了两个，少组了两个是奇数和偶数
        这两个只可能是：
        偶数：两个奇数或者是一个偶数
        奇数：单个奇数
        那么可以把奇数拆掉，换成偶数前面的一个奇数
        还剩一个，
        还剩两个的情况呢?
        还剩两个刚好搞成一个偶数，还剩三个呢？
        还剩三个刚好两个，而且并不会引起问题
        还剩四个呢，四个的话就必须3+1，所以也只有两个
        五个呢，先2+1+2
        六个呢，就是2+1+2+1
        七个呢，就是2+1+3+1
        所以答案要先除以3
        除以3之后看除以3之后的余数
        比如说7/3余1 那么答案就是(7/3)*2
        四个呢 （4/3）*2
        如果余2呢
        （5/3）*2+1
        余0 （6/3）*2
        */
    }else{
        //剩下的情况就是说我现在偶数的数量比奇数的数量要多了，那么比较简单了，
        /*
        我先上一个偶数
        再上一个奇数
        如此反复，一直上到没有了奇数
        那我现在在上所有偶数
        上了多少个数了（奇数数量*2+1）
        */
       cout&lt;&lt;odd*2+1&lt;&lt;endl;
    }
    return 0;
}
</code></pre>
<h2 id="t3-just-stalling">T3 Just Stalling</h2>
<h4 id="题面描述-3">题面描述</h4>
<p>Farmer John 有 N 头奶牛（1≤N≤20），高度为 a1…aN。他的牛栏有 N 个牛棚，高度限制分别为 b1…bN（例如，如果 b5=17，那么一头高度不超过 17 的奶牛可以住在牛棚 5 里）。Farmer John 有多少种不同的方式安排他的奶牛，使得每头奶牛均住在不同的牛棚里，并且使得每个牛棚的高度限制均得到满足？</p>
<h4 id="输入格式从终端标准输入读入-3">输入格式（从终端/标准输入读入）：</h4>
<p>输入的第一行包含 N。第二行包含 N 个空格分隔的整数 a1,a2,…,aN。第三行包含 N 个空格分隔的整数 b1,b2,…,bN。所有的高度和高度限制均在范围 [1,109] 内。</p>
<h4 id="输出格式输出至终端标准输出-3">输出格式（输出至终端/标准输出）：</h4>
<p>输出 Farmer John 可以将每头奶牛安排到不同的牛棚里，使得每个牛棚的高度限制均得到满足的方法数。注意输出的数量可能需要使用 64 位整数型，例如 C++ 中的 long long。</p>
<h4 id="输入样例-2">输入样例：</h4>
<p>4<br>
1 2 3 4<br>
2 4 3 4</p>
<h4 id="输出样例-2">输出样例：</h4>
<p>8<br>
在这个例子中，我们不能将第三头奶牛安排到第一个牛棚里，因为 3=a3&gt;b1=2。类似地，我们不能将第四头奶牛安排到第一或第三个牛棚里。一种符合高度限制的安排方式为将奶牛 1 安排到牛棚 1，奶牛 2 安排到牛棚 2，奶牛 3 安排到牛棚 3，奶牛 4 安排到牛棚 4。</p>
<h4 id="测试点性质-2">测试点性质：</h4>
<p>测试点 1-5 满足 N≤8。<br>
测试点 6-12 没有额外限制。</p>
<h4 id="解题思路-2">解题思路</h4>
<p>其实，一开始的时候我这题根本就做不出来，因为我这一题将高度这个重要条件省略了，我直接用高度模拟出这个二分图中那两条边可以连接，然后一直在想优化暴力的方法。直到我突然想到，我的方法不论怎么优化，都必须把每一种方式都搜一遍，然后这个答案在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>long long</mtext></mrow><annotation encoding="application/x-tex">\text{long long}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord text"><span class="mord">long long</span></span></span></span></span>之内，不爆炸才怪。</p>
<p>然后，稍微看了一眼答案，感觉做法非常巧。</p>
<p>主要是强行构造乘法原理可以套上去的状态，然后再进行计算。</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define pb push_back
using namespace std;
template &lt;typename T&gt;inline void read(T&amp; t){
    t=0; register char ch=getchar();
    while(!('0'&lt;=ch&amp;&amp;ch&lt;='9')){if(ch=='-') t=-1;ch=getchar();}
    while(('0'&lt;=ch&amp;&amp;ch&lt;='9')){t=((t&lt;&lt;1)+(t&lt;&lt;3))+ch-'0'; ch=getchar();}
}
template &lt;typename T,typename... Args&gt; inline void read(T&amp; t, Args&amp;... args){
    read(t);read(args...);
}
template &lt;typename T&gt;inline void write(T x){
    if(x&lt;0) putchar('-'),x=~(x-1); int s[40],top=0;
    while(x) s[++top]=x%10,x/=10; if(!top) s[++top]=0;
    while(top) putchar(s[top--]+'0');
}
int n,a[114],b[514];
bool cmp(const int &amp;infoa,const int &amp;infob){
    return infoa&gt;infob;
}
long long ans=1;
int main(){
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;++i) cin&gt;&gt;a[i];
    for(int i=1;i&lt;=n;++i) cin&gt;&gt;b[i];
    sort(a+1,a+n+1,cmp);
    for(int i=1;i&lt;=n;++i){
        int sum=0;
        /*
        现在将奶牛的高度按降序来排一下。
        然后一个一个牛棚去考虑
        主要是想用乘法原理算。
        怎么算，就是说，我现在知道了
        第i个位置有sum个位置可以放。
        这时候会想到，i-1个位置中放的地方，一定在这sum个东西中间
        那么我这一位其实只sum-i+1种方法可以选择。这种方法是对的么？
        */
        for(int j=1;j&lt;=n;++j)
            if(b[j]&gt;=a[i]) sum++;
        ans*=(sum-i+1);
    }
    cout&lt;&lt;ans&lt;&lt;endl;
    return 0;
}
</code></pre>
<p>完结撒花！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2020 December Contest Bronze 题解]]></title>
        <id>https://mercurycity.github.io/post/2020-december-contest-bronze-ti-jie/</id>
        <link href="https://mercurycity.github.io/post/2020-december-contest-bronze-ti-jie/">
        </link>
        <updated>2021-07-03T06:44:25.000Z</updated>
        <content type="html"><![CDATA[<h2 id="t1-do-you-know-your-abcs">T1  Do You Know Your ABCs?</h2>
<h3 id="题面描述">题面描述：</h3>
<p>Farmer John 的奶牛正在 &quot;mooZ&quot; 视频会议平台上举行每日集会。她们发明了一个简单的数字游戏，为会议增添一些乐趣。</p>
<p>Elsie 有三个正整数 A、B 和 C（A≤B≤C）。这些数字是保密的，她不会直接透露给她的姐妹 Bessie。她告诉 Bessie 七个范围在 1…109 之间的整数（不一定各不相同），并宣称这是 A、B、C、A+B、B+C、C+A 和 A+B+C 的某种排列。</p>
<p>给定这七个整数，请帮助 Bessie 求出 A、B 和 C。可以证明，答案是唯一的。</p>
<h4 id="输入格式从终端标准输入读入">输入格式（从终端/标准输入读入）：</h4>
<p>输入一行，包含七个空格分隔的整数。</p>
<h4 id="输出格式输出至终端标准输出">输出格式（输出至终端/标准输出）：</h4>
<p>输出 A、B 和 C，用空格分隔。</p>
<h4 id="输入样例">输入样例：</h4>
<p>2 2 11 4 9 7 9</p>
<h4 id="输出样例">输出样例：</h4>
<p>2 2 7</p>
<h4 id="测试点性质">测试点性质：</h4>
<p>测试点 2-3 满足 C≤50。<br>
测试点 4-10 没有额外限制。</p>
<h4 id="解题思路">解题思路</h4>
<p>显然</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∀</mi><mtext>A,B,C</mtext><mo>∈</mo><mi mathvariant="double-struck">N</mi></mrow><annotation encoding="application/x-tex">\forall \text{\text{A,B,C}} \in \mathbb{N}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">∀</span><span class="mord text"><span class="mord text"><span class="mord">A,B,C</span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">N</span></span></span></span></span></span></p>
<p>所以，从小到大排序，然后最小的两个一定是ABC中的一个</p>
<p>然后就需要判断第三个是不是另外一个</p>
<p>然后会发现，当且仅当如果A+B刚好等于第三个时，那么这时第四个才是C<br>
其他情况，C必定为第三个。</p>
<p>简单思考题。</p>
<p>Code:</p>
<pre><code>die码当时没保存，┭┮﹏┭┮
</code></pre>
<h2 id="t2-daisy-chains">T2 Daisy Chains</h2>
<h3 id="题面描述-2">题面描述</h3>
<p>每天，作为她绕农场行走的一部分，奶牛 Bessie 会经过她最喜爱的草地，其中种有 N 朵花（五颜六色的雏菊），编号为 1…N（1≤N≤100），排列成一行。花 i 有 pi 朵花瓣（1≤pi≤1000）。<br>
作为一名崭露头角的摄影家，Bessie 决定给这些花拍些照片。具体地说，对于每一对满足 1≤i≤j≤N 的花 (i,j)，Bessie 会给从花 i 到花 j 之间的所有花（包括 i 和 j）拍一张照。</p>
<p>后来 Bessie 查看这些照片时注意到有些照片里存在「平均」的花——一朵恰好有 P 朵花瓣的花，其中 P 等于照片中所有花的花瓣数量的平均值。</p>
<p>Bessie 的照片中有几张存在平均的花？</p>
<h4 id="输入格式从终端标准输入读入-2">输入格式（从终端/标准输入读入）：</h4>
<p>输入的第一行包含 N。第二行包含 N 个空格分隔的整数 p1…pN。</p>
<h4 id="输出格式输出至终端标准输出-2">输出格式（输出至终端/标准输出）：</h4>
<p>输出存在平均的花的照片数量。</p>
<h4 id="输入样例-2">输入样例：</h4>
<p>4<br>
1 1 2 3</p>
<h4 id="输出样例-2">输出样例：</h4>
<p>6</p>
<h4 id="样例解释">样例解释</h4>
<p>每张仅包含一朵花的照片均会被计入答案（在这个样例中有 4 张）。另外，在这个样例中 (i,j) 为 (1,2) 和 (2,4) 所对应的照片也存在平均的花。</p>
<h4 id="解题思路-2">解题思路</h4>
<p>数据量很小，直接暴力模拟。</p>
<p>同样，die码没有保存。。</p>
<h2 id="t3-stuck-in-a-rut">T3 Stuck in a Rut</h2>
<h4 id="题面描述-3">题面描述</h4>
<p>Farmer John 最近扩大了他的农场，从奶牛们的角度看来这个农场相当于是无限大了！奶牛们将农场上放牧的区域想作是一个由正方形方格组成的无限大二维方阵，每个方格中均有美味的草（将每个方格看作是棋盘上的一个方格）。Farmer John 的 N 头奶牛（1≤N≤50）初始时位于不同的方格中，一部分朝向北面，一部分朝向东面。<br>
每一小时，每头奶牛会执行以下二者之一：</p>
<p>如果她当前所在的方格里的草已经被其他奶牛吃掉了，则她会停下。<br>
吃完她当前所在的方格中的所有草，并向她朝向的方向移动一个方格。<br>
经过一段时间，每头奶牛的身后会留下一条被啃秃了的轨迹。</p>
<p>如果两头奶牛在一次移动中移动到了同一个有草的方格，她们会分享这个方格中的草，并在下一个小时继续沿她们朝向的方向移动。</p>
<p>请求出每头奶牛吃到的草的数量。有些奶牛永远不会停下，从而吃到无限多的草。</p>
<h4 id="输入格式从终端标准输入读入-3">输入格式（从终端/标准输入读入）：</h4>
<p>输入的第一行包含 N。以下 N 行，每行描述一头奶牛的起始位置，包含一个字符 N（表示朝向北面） 或 E（表示朝向东面），以及两个非负整数 x 和 y（0≤x≤109，0≤y≤109）表示方格的坐标。所有 x 坐标各不相同，所有 y 坐标各不相同。<br>
为了使方向和坐标尽可能明确，如果一头奶牛位于方格 (x,y) 并向北移动，她会到达方格 (x,y+1)。如果她向东移动，她会到达方格 (x+1,y)。</p>
<h4 id="输出格式输出至终端标准输出-3">输出格式（输出至终端/标准输出）：</h4>
<p>输出 N 行。输出的第 i 行包含输入中的第 i 头奶牛吃到草的方格的数量。如果一头奶牛可以吃到无限多的草，为这头奶牛输出 &quot;Infinity&quot;。</p>
<h4 id="输入样例-3">输入样例：</h4>
<p>6<br>
E 3 5<br>
N 5 3<br>
E 4 6<br>
E 10 4<br>
N 11 2<br>
N 8 1</p>
<h4 id="输出样例-3">输出样例：</h4>
<p>5<br>
3<br>
Infinity<br>
Infinity<br>
2<br>
5</p>
<h4 id="测试点性质-2">测试点性质：</h4>
<p>测试点 2-5 中，所有坐标不超过 100。<br>
测试点 6-10 没有额外限制。</p>
<h4 id="解题思路-3">解题思路</h4>
<p>说实话，真是一道好（duliu）题。</p>
<p>做了很久，个人思路就是将可能会相遇的点全部保存下来，然后一个一个进行筛选。</p>
<p>筛选的时候要注意，你不能只用一个book数组记录哪一个点已经停了下来，而是应该继续记录那个点运动了多少，下一次如果运动不到应该运动到的相遇地方，就pass。</p>
<h4 id="蒟蒻die码">蒟蒻die码</h4>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define pb push_back
using namespace std;
template &lt;typename T&gt;inline void read(T&amp; t){
    t=0; register char ch=getchar();
    while(!('0'&lt;=ch&amp;&amp;ch&lt;='9')){if(ch=='-') t=-1;ch=getchar();}
    while(('0'&lt;=ch&amp;&amp;ch&lt;='9')){t=((t&lt;&lt;1)+(t&lt;&lt;3))+ch-'0'; ch=getchar();}
}
template &lt;typename T,typename... Args&gt; inline void read(T&amp; t, Args&amp;... args){
    read(t);read(args...);
}
template &lt;typename T&gt;inline void write(T x){
    if(x&lt;0) putchar('-'),x=~(x-1); int s[40],top=0;
    while(x) s[++top]=x%10,x/=10; if(!top) s[++top]=0;
    while(top) putchar(s[top--]+'0');
}
int n;
int dis[114514];
vector&lt;pair&lt;int,pair&lt;int,int&gt; &gt; &gt;Up,Right;
struct Meet{
    int x,y,lt,rt,mint;
    bool w;
    int ai,bi;
    bool operator &lt; (const Meet &amp;MeEt) const{
        return mint&lt;MeEt.mint;
    }
    void print(){
        cout&lt;&lt;lt&lt;&lt;' '&lt;&lt;rt&lt;&lt;' '&lt;&lt;mint&lt;&lt;' '&lt;&lt;w&lt;&lt;' '&lt;&lt;ai&lt;&lt;' '&lt;&lt;bi&lt;&lt;endl;;
    }
};
bool book[114514];
int boko[114514];
vector&lt;Meet&gt;meet;
int main(){
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;++i){
        char ch;
        cin&gt;&gt;ch;
        int x,y;
        read(x,y);
        if(ch=='E')
            Right.pb(make_pair(x,make_pair(y,i)));
        else
            Up.pb(make_pair(x,make_pair(y,i)));
    }
    for(int i=0;i&lt;Right.size();++i)
        for(int j=0;j&lt;Up.size();++j){
            #define x first
            #define y second.first
            #define idx second.second
            if(Right[i].x&gt;Up[j].x||Right[i].y&lt;Up[j].y) continue;
            int bx=Up[j].x,by=Right[i].y;
            meet.pb({bx,by,bx-Right[i].x,by-Up[j].y,min(bx-Right[i].x,by-Up[j].y),(bx-Right[i].x&lt;by-Up[j].y),Right[i].second.second,Up[j].second.second});
            #undef x
            #undef y
            #undef idx
        }
    sort(meet.begin(),meet.end());
    memset(book,0,sizeof(book));
    memset(dis,0x3f,sizeof(dis));
    for(int i=0;i&lt;meet.size();++i){
        if(book[meet[i].ai]||book[meet[i].bi]){
            //如果两个之中有一个之前已经被碰过了
            if(book[meet[i].ai]&amp;&amp;boko[meet[i].ai]/*向右的最大距离*/&lt;meet[i].x/*比我碰面的距离*/) continue;
            if(book[meet[i].bi]&amp;&amp;boko[meet[i].bi]/*向上的最大距离*/&lt;meet[i].y/*比我碰面的距离*/) continue;
           //这里的判断有问题，就是说，就算我有一个碰过了，但是草还是会被吃掉那个时候，所以很难搞
           //我一个book应该存的是，如果我停止了，那么我草吃到了哪里，而不是有没有被碰掉
           //book存完之后，就只需要判断一下我这个被碰过的点有没有走到那个位置就ok了。
        }
        if(meet[i].lt==meet[i].rt) continue;
        if(meet[i].w){
            dis[meet[i].bi]=meet[i].rt;
            book[meet[i].bi]=1;
            boko[meet[i].bi]=meet[i].y;//现在我这个是向上走的,并且我现在只可以走到meet[i].y的位置了。
        }else{
            dis[meet[i].ai]=meet[i].lt;
            book[meet[i].ai]=1;
            boko[meet[i].ai]=meet[i].x;//现在我这个是向上走的,并且我现在只可以走到meet[i].y的位置了。
        }
    }
    for(int i=1;i&lt;=n;++i) if(dis[i]==0x3f3f3f3f) cout&lt;&lt;&quot;Infinity&quot;&lt;&lt;'\n';
    else cout&lt;&lt;dis[i]&lt;&lt;'\n';
    return 0;
}
</code></pre>
]]></content>
    </entry>
</feed>