<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://mercurycity.github.io</id>
    <title>Mercury的小屋</title>
    <updated>2021-07-05T14:20:29.122Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://mercurycity.github.io"/>
    <link rel="self" href="https://mercurycity.github.io/atom.xml"/>
    <subtitle>刘玖拾的一个小屋，专门端捧刘玖拾的梦想。</subtitle>
    <logo>https://mercurycity.github.io/images/avatar.png</logo>
    <icon>https://mercurycity.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Mercury的小屋</rights>
    <entry>
        <title type="html"><![CDATA[人生第一道交互题！洛谷P1947 猜数 个人题解]]></title>
        <id>https://mercurycity.github.io/post/ren-sheng-di-yi-dao-jiao-hu-ti-luo-gu-p1947-cai-shu-ge-ren-ti-jie/</id>
        <link href="https://mercurycity.github.io/post/ren-sheng-di-yi-dao-jiao-hu-ti-luo-gu-p1947-cai-shu-ge-ren-ti-jie/">
        </link>
        <updated>2021-07-05T13:52:42.000Z</updated>
        <content type="html"><![CDATA[<h2 id="洛谷p1947-猜数">洛谷P1947 猜数</h2>
<h3 id="题目背景">题目背景</h3>
<p>这是一道交互题。</p>
<h3 id="题目描述">题目描述</h3>
<p>珂愛给了你一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mn>1</mn><mo separator="true">,</mo><mi>n</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[1,n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">]</span></span></span></span> 之间的整数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> ，你每次可以询问一个整数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> ，然后珂愛会告诉你 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 的大小关系。</p>
<p>你需要用尽可能少的次数猜出珂愛想的数。</p>
<p>你需要实现一个函数 int Chtholly(int n,int c)，这个函数的作用是在不超过 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span> 次询问中猜对 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mn>1</mn><mo separator="true">,</mo><mi>n</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[1,n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">]</span></span></span></span> 中的一个数，返回值为你最终确定的数。</p>
<p>你可以调用交互库中一个叫做 Seniorious 的函数，其原型为 int Seniorious(int x)，返回值为：</p>
<p>若 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>&lt;</mo><mi>x</mi><mi>k</mi><mo>&lt;</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">k\lt xk&lt;x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">x</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>，则返回 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 。<br>
若<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>&gt;</mo><mi>x</mi><mi>k</mi><mo>&gt;</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">k\gt xk&gt;x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">x</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>，则返回 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">−</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">−1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span> 。<br>
若 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>=</mo><mi>x</mi><mi>k</mi><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">k=xk=x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>，则返回 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 。<br>
你调用 Seniorious 函数的次数不超过 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span> 才能得到这个点的分数，否则这个点为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 分。有关该函数的调用请参考【说明/提示】部分。</p>
<p>由于珂愛只会写 C++ 语言的交互库，所以你只能使用 C++ 语言（包括 C++，C++11，C++14，C++17）来解决本题。</p>
<h3 id="输入格式">输入格式</h3>
<p>样例输入中三个数分别为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 。这些数据你都无法读取。</p>
<h3 id="输出格式">输出格式</h3>
<p>样例输出中第一个数是你猜的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>，第二个数是你调用 Seniorious 函数的次数。这些数据你不必输出。</p>
<h3 id="输入输出样例">输入输出样例</h3>
<h4 id="输入">输入</h4>
<p>5 5 3</p>
<h4 id="输出">输出</h4>
<p>3 0</p>
<h3 id="说明提示">说明/提示</h3>
<h4 id="样例解释">样例解释</h4>
<p>你要猜的 kk 为 33。</p>
<p>由于你和珂愛心灵相通，所以在没有调用 Seniorious 的情况下就猜出来了。</p>
<h4 id="数据规模与约定">数据规模与约定</h4>
<p>对于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>30</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">30\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">3</span><span class="mord">0</span><span class="mord">%</span></span></span></span> 的数据，保证 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mo>=</mo><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">c=n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。<br>
对于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>100</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">100\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">%</span></span></span></span> 的数据，保证 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup></mrow><annotation encoding="application/x-tex">2\leq n\leq 10^6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>min</mi><mo>⁡</mo><mo>(</mo><mn>20</mn><mo separator="true">,</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>)</mo><mo>≤</mo><mi>c</mi><mo>≤</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">\min(20,n-1)\leq c\leq n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">min</span><span class="mopen">(</span><span class="mord">2</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>。</p>
<h2 id="如何氵题">如何氵题</h2>
<p>首先，第一道交互题，我并没有选择IO交互，因为现在貌似所有大考都是grader交互呢。（虽然容易被草过去）</p>
<p>做了这个题目，第一个学会的是<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi><mi>x</mi><mi>t</mi><mi>e</mi><mi>r</mi><mi>n</mi><mi mathvariant="normal">&quot;</mi><mi>C</mi><mi mathvariant="normal">&quot;</mi></mrow><annotation encoding="application/x-tex">extern &quot;C&quot;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">n</span><span class="mord">&quot;</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord">&quot;</span></span></span></span>这个东西加在了一个函数的前面，那么说明这个函数是交互函数。<br>
并且，似乎这种题目就是让你写完一个函数，然后返回一个正确的值就ok了。<br>
在完成这个函数的同时，他会给你一些辅助函数，这些函数都是非常有用的（除非你当打CTF一样打OI）。</p>
<p>好的，这个程序我们一行一行分析，首先第一行。</p>
<pre><code class="language-cpp">extern &quot;C&quot; int Seniorious(int);
</code></pre>
<p>明显，声明一下这个是出题人给的函数，并且这个函数是出题人给的，不是我们完善的，只需要声明就OK了。</p>
<p>好，然后是需要我们完成的函数。</p>
<pre><code class="language-cpp">extern &quot;C&quot; int Chtholly(int n,int c){
    int left=1,right=n;
    while(left&lt;right){
        int mid=(left+right)/2;
        int pos=Seniorious(mid);
        if(pos==0){
            return mid;
            break;
        }
        if(pos==1) right=mid-1;
        else left=mid+1;
    }
    return left;
}
</code></pre>
<p>下一次开二分搜索的坑。</p>
<p>这里不着重讲二分搜索，主要讲交互题的格式之类的。</p>
<p>首先，声明一下这个函数叫Chtholly。<span class="katex"><span class="katex-mathml"><math><semantics><mrow><menclose notation="horizontalstrike"><mrow><mi mathvariant="normal">我</mi><mi mathvariant="normal">永</mi><mi mathvariant="normal">远</mi><mi mathvariant="normal">爱</mi><mi mathvariant="normal">珂</mi><mi mathvariant="normal">朵</mi><mi mathvariant="normal">莉</mi></mrow></menclose></mrow><annotation encoding="application/x-tex">\sout{我永远爱珂朵莉}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.2555em;vertical-align:0em;"></span><span class="mord"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.2555em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">我</span><span class="mord cjk_fallback">永</span><span class="mord cjk_fallback">远</span><span class="mord cjk_fallback">爱</span><span class="mord cjk_fallback">珂</span><span class="mord cjk_fallback">朵</span><span class="mord cjk_fallback">莉</span></span></span><span style="top:-3.2155em;"><span class="pstrut" style="height:3em;"></span><span class="stretchy sout"></span></span></span></span></span></span></span></span></span> 然后呢，先定义一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo>=</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">left=1,right=n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>，表示一个区间。这个区间里应该存的是可以满足条件的数的整个数组。</p>
<p>好，然后这一步非常关键</p>
<pre><code class="language-cpp">    int pos=Seniorious(mid);
</code></pre>
<p>这一步就是说明，我现在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>o</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">pos</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span></span></span></span>来去访问一下你的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>e</mi><mi>n</mi><mi>i</mi><mi>o</mi><mi>r</mi><mi>i</mi><mi>o</mi><mi>u</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">Seniorious</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault">u</span><span class="mord mathdefault">s</span></span></span></span>函数，然后返回一个值，交互交互，这就是向评测姬提问的过程。</p>
<p>然后就是朴素二分的写法，这里不多赘述。</p>
<pre><code class="language-cpp">    return left;
</code></pre>
<p>最后要求的答案是找到的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>，显然，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>如果在外部的话，那这个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>=</mo><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mo>=</mo><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">k=left=right</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span></span></span></span>，随便返回一个都ok了。</p>
<p>完结撒花！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2021 January Contest Bronze 题解]]></title>
        <id>https://mercurycity.github.io/post/2021-january-contest-bronze-ti-jie/</id>
        <link href="https://mercurycity.github.io/post/2021-january-contest-bronze-ti-jie/">
        </link>
        <updated>2021-07-04T10:57:32.000Z</updated>
        <content type="html"><![CDATA[<h2 id="t1-uddered-but-not-herd">T1 Uddered but not Herd</h2>
<h4 id="题面描述">题面描述</h4>
<p>一个鲜为人知的事实是，奶牛拥有自己的文字：「牛文」。牛文由 26 个字母 'a' 到 'z' 组成，但是当奶牛说牛文时，可能与我们所熟悉的 'abcdefghijklmnopqrstuvwxyz' 不同，她会按某种特定的顺序排列字母。<br>
为了打发时间，奶牛 Bessie 在反复哼唱牛文字母歌，而 Farmer John 好奇她唱了多少遍。</p>
<p>给定一个小写字母组成的字符串，为 Farmer John 听到 Bessie 唱的字母，计算 Bessie 至少唱了几遍完整的牛文字母歌，使得 Farmer John 能够听到给定的字符串。Farmer John 并不始终注意 Bessie 所唱的内容，所以他可能会漏听 Bessie 唱过的一些字母。给定的字符串仅包含他记得他所听到的字母。</p>
<h4 id="输入格式从终端标准输入读入">输入格式（从终端/标准输入读入）：</h4>
<p>输入的第一行包含 26 个小写字母 'a' 到 'z' 的牛文字母表顺序。下一行包含一个小写字母组成的字符串，为 Farmer John 听到 Bessie 唱的字母。字符串的长度不小于 1 且不大于 1000。</p>
<h4 id="输出格式输出至终端标准输出">输出格式（输出至终端/标准输出）：</h4>
<p>输出 Bessie 所唱的完整的牛文字母歌的最小次数。</p>
<h4 id="输入样例">输入样例：</h4>
<p>abcdefghijklmnopqrstuvwxyz<br>
mood</p>
<h4 id="输出样例">输出样例：</h4>
<p>3</p>
<h4 id="样例解释">样例解释</h4>
<p>在这个样例中，牛文字母表与日常的字母表的排列一致。<br>
Bessie 至少唱了三遍牛文字母歌。有可能 Bessie 只唱了三遍牛文字母歌，而 Farmer John 听到了以下被标记为大写的字母。<br>
abcdefghijklMnOpqrstuvwxyz<br>
abcdefghijklmnOpqrstuvwxyz<br>
abcDefghijklmnopqrstuvwxyz</p>
<h4 id="测试点性质">测试点性质：</h4>
<p>测试点 2-5 中，牛文字母表与日常的字母表相同。<br>
测试点 6-10 没有额外限制。</p>
<p>试图直接用一个公式直接写出此题答案，罢了，根本不会写。</p>
<p>好的，那么这题的思路非常的显然，就是说，如果我现在这一位的字符对于前一位字符来说在字母表的较前位置，这显然是不合法的。同时，须要注意的是，如果现在又连续两位的字符，那么肯定是唱了两遍歌的毋庸置疑。</p>
<p>蒟蒻die码：</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define pb push_back
using namespace std;
template &lt;typename T&gt;inline void read(T&amp; t){
    t=0; register char ch=getchar();
    while(!('0'&lt;=ch&amp;&amp;ch&lt;='9')){if(ch=='-') t=-1;ch=getchar();}
    while(('0'&lt;=ch&amp;&amp;ch&lt;='9')){t=((t&lt;&lt;1)+(t&lt;&lt;3))+ch-'0'; ch=getchar();}
}
template &lt;typename T,typename... Args&gt; inline void read(T&amp; t, Args&amp;... args){
    read(t);read(args...);
}
template &lt;typename T&gt;inline void write(T x){
    if(x&lt;0) putchar('-'),x=~(x-1); int s[40],top=0;
    while(x) s[++top]=x%10,x/=10; if(!top) s[++top]=0;
    while(top) putchar(s[top--]+'0');
}
string st;
bool later(char ch1,char ch2){
    //写了一个函数来判断ch1是不是在ch2后
    //同时，如果ch1完全等于ch2时，这说明我读了两遍一个词，这直接累加答案
    if(ch1==ch2) return 1;
    for(int i=0;i&lt;st.size();++i){
        if(st[i]==ch1) return 0;
        if(st[i]==ch2) return 1;
    }
    return 0; //其实不会到这个时候了
}
int ans;
string st1;
int main(){
    cin&gt;&gt;st&gt;&gt;st1;
    char lch=st1[0];
    for(int i=1;i&lt;st1.size();++i){
        if(later(lch,st1[i])) ans++;
        lch=st1[i];
    }
    cout&lt;&lt;ans+1&lt;&lt;endl;
    return 0;
}
</code></pre>
<h2 id="t2-even-more-odd-photos">T2 Even More Odd Photos</h2>
<h4 id="题面描述-2">题面描述</h4>
<p>Farmer John 正再一次尝试给他的 N 头奶牛拍照（2≤N≤1000）。<br>
每头奶牛有一个范围在 1…100 之内的整数的「品种编号」。Farmer John 对他的照片有一个十分古怪的构思：他希望将所有的奶牛分为不相交的若干组（换句话说，将每头奶牛分到恰好一组中）并将这些组排成一行，使得第一组的奶牛的品种编号之和为偶数，第二组的编号之和为奇数，以此类推，奇偶交替。<br>
Farmer John 可以分成的最大组数是多少？</p>
<h4 id="输入格式从终端标准输入读入-2">输入格式（从终端/标准输入读入）：</h4>
<p>输入的第一行包含 N。下一行包含 N 个空格分隔的整数，为 N 头奶牛的品种编号。</p>
<h4 id="输出格式输出至终端标准输出-2">输出格式（输出至终端/标准输出）：</h4>
<p>输出 Farmer John 的照片中的最大组数。可以证明，至少存在一种符合要求的分组方案。</p>
<h4 id="输入样例1">输入样例1：</h4>
<p>7<br>
1 3 5 7 9 11 13</p>
<h4 id="输出样例1">输出样例1：</h4>
<p>3</p>
<h4 id="样例解释1">样例解释1</h4>
<p>在这个样例中，以下是一种分成最大组数三组的方案。将 1 和 3 分在第一组，5、7 和 9 分在第二组，11 和 13 分在第三组。</p>
<h4 id="输入样例2">输入样例2：</h4>
<p>7<br>
11 2 17 13 1 15 3</p>
<h4 id="输出样例2">输出样例2：</h4>
<p>5</p>
<h4 id="样例解释3">样例解释3：</h4>
<p>在这个样例中，以下是一种分成最大组数五组的方案。将 2 分在第一组，11 分在第二组，13 和 1 分在第三组，15 分在第四组，17 和 3 分在第五组。</p>
<h4 id="解题思路">解题思路：</h4>
<p>感觉就是一个大模拟，想了很久。详细内容不说了，见die码。附注，USACO给出的标准答案似乎die码复杂度比我的高：</p>
<p>算了，还是稍微讲一讲，避免未来又忘了这一题怎么做了。</p>
<p>首先的首先，会发现这一题其实数字大小没什么用，只是其奇偶性会改变很多。</p>
<p>ok首先，明显的一个贪心思路，就是说，如果我现在需要一个奇数，我肯定是上一个奇数，而不是上一个偶数加上一个奇数，因为明显，这个偶数可以放在后面一位来多创造一个价值。</p>
<p>根据这个思路，我现在先将偶数的数量和奇数的数量统计好。<br>
然后现在判断是偶数数量多还是奇数数量多。<br>
从简单开始，如果是偶数数量多，那么放偶数奇数偶数奇数，会发现放到最后一个奇数之后的那个偶数后，再多的偶数也只能叠加到前面去，创造不出一个新的奇数了，所以说这个答案比较简单，就是奇数数量*2+1。这是一个比较简单的情况。<br>
如果一样多，那么答案很显然就是两个数量加起来<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>n</mtext></mrow><annotation encoding="application/x-tex">\text{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord text"><span class="mord">n</span></span></span></span></span><br>
由简至繁，如果现在是奇数数量多。<br>
插一句题外话，为什么奇数数量多更加的复杂，其实很好理解，就是说，奇数数量多出来了，我两个奇数可以合成偶数，放一个奇数在别的地方会改变奇偶性，所以说明显是奇数数量多更加复杂。<br>
好，回归正题，如果是奇数数量多的时候呢。不妨把可以消耗的偶数全部消耗完毕（反正迟早也是必须的嘛。<br>
我现在的答案就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>n</mi><mi>s</mi><mo>×</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">ans\times 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>然后呢，我现在还剩奇数的个数减去偶数的个数个奇数（好像很绕）。<br>
假设我现在还剩<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>pos</mtext></mrow><annotation encoding="application/x-tex">\text{pos}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord text"><span class="mord">pos</span></span></span></span></span>个奇数，貌似是个找规律呢，打个表。</p>
<p>其实表格是有一个很好看的的，但是我不会写<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>LaTeX</mtext></mrow><annotation encoding="application/x-tex">\LaTeX</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.89883em;vertical-align:-0.2155em;"></span><span class="mord text"><span class="mord textrm">L</span><span class="mspace" style="margin-right:-0.36em;"></span><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.68333em;"><span style="top:-2.904999em;"><span class="pstrut" style="height:2.7em;"></span><span class="mord text"><span class="mord textrm sizing reset-size6 size3">A</span></span></span></span></span></span><span class="mspace" style="margin-right:-0.15em;"></span><span class="mord text"><span class="mord textrm">T</span><span class="mspace" style="margin-right:-0.1667em;"></span><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.46782999999999997em;"><span style="top:-2.7845em;"><span class="pstrut" style="height:3em;"></span><span class="mord text"><span class="mord textrm">E</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2155em;"><span></span></span></span></span><span class="mspace" style="margin-right:-0.125em;"></span><span class="mord textrm">X</span></span></span></span></span></span>，罢了罢了。<br>
pos	<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Δ</mi></mrow><annotation encoding="application/x-tex">\Delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Δ</span></span></span></span> ans<br>
1	 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mspace width="1em"/></mrow><annotation encoding="application/x-tex">\quad</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mspace" style="margin-right:1em;"></span></span></span></span>  -1<br>
2	 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mspace width="1em"/></mrow><annotation encoding="application/x-tex">\quad</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mspace" style="margin-right:1em;"></span></span></span></span>   1<br>
3    <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mspace width="1em"/></mrow><annotation encoding="application/x-tex">\quad</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mspace" style="margin-right:1em;"></span></span></span></span>   2<br>
4    <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mspace width="1em"/></mrow><annotation encoding="application/x-tex">\quad</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mspace" style="margin-right:1em;"></span></span></span></span>   1<br>
5    <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mspace width="1em"/></mrow><annotation encoding="application/x-tex">\quad</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mspace" style="margin-right:1em;"></span></span></span></span>   3<br>
6	 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mspace width="1em"/></mrow><annotation encoding="application/x-tex">\quad</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mspace" style="margin-right:1em;"></span></span></span></span>   4<br>
7    <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mspace width="1em"/></mrow><annotation encoding="application/x-tex">\quad</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mspace" style="margin-right:1em;"></span></span></span></span>   3</p>
<p>好，现在不难发现规律，规律就不用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>LaTeX</mtext></mrow><annotation encoding="application/x-tex">\LaTeX</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.89883em;vertical-align:-0.2155em;"></span><span class="mord text"><span class="mord textrm">L</span><span class="mspace" style="margin-right:-0.36em;"></span><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.68333em;"><span style="top:-2.904999em;"><span class="pstrut" style="height:2.7em;"></span><span class="mord text"><span class="mord textrm sizing reset-size6 size3">A</span></span></span></span></span></span><span class="mspace" style="margin-right:-0.15em;"></span><span class="mord text"><span class="mord textrm">T</span><span class="mspace" style="margin-right:-0.1667em;"></span><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.46782999999999997em;"><span style="top:-2.7845em;"><span class="pstrut" style="height:3em;"></span><span class="mord text"><span class="mord textrm">E</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2155em;"><span></span></span></span></span><span class="mspace" style="margin-right:-0.125em;"></span><span class="mord textrm">X</span></span></span></span></span></span>写了</p>
<p>蒟蒻die码：</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define pb push_back
using namespace std;
template &lt;typename T&gt;inline void read(T&amp; t){
    t=0; register char ch=getchar();
    while(!('0'&lt;=ch&amp;&amp;ch&lt;='9')){if(ch=='-') t=-1;ch=getchar();}
    while(('0'&lt;=ch&amp;&amp;ch&lt;='9')){t=((t&lt;&lt;1)+(t&lt;&lt;3))+ch-'0'; ch=getchar();}
}
template &lt;typename T,typename... Args&gt; inline void read(T&amp; t, Args&amp;... args){
    read(t);read(args...);
}
template &lt;typename T&gt;inline void write(T x){
    if(x&lt;0) putchar('-'),x=~(x-1); int s[40],top=0;
    while(x) s[++top]=x%10,x/=10; if(!top) s[++top]=0;
    while(top) putchar(s[top--]+'0');
}
int n;
int odd,even,ans;
int main(){
    cin&gt;&gt;n;
    while(n--){
        int t;
        read(t);
        if(t%2==0) even++;
        else odd++;
    }
    if(odd==even){
        cout&lt;&lt;odd&lt;&lt;endl;
        return 0;
    }
    //好，现在知道了这个过程，就模拟它
    //现在要构造第一组是偶数，第二组是奇数，就一直这样，那么先看是偶数多还是奇数多
    if(odd&gt;even){
        //奇数多，答案先累加一下偶数
        ans=even*2;
        //要贡献even个奇数
        odd=odd-even;
        if(odd%3==1)
            cout&lt;&lt;(odd/3)*2-1+ans&lt;&lt;endl;
        else 
            if(odd%3==0)
                cout&lt;&lt;(odd/3)*2+ans&lt;&lt;endl;
            else
                cout&lt;&lt;(odd/3)*2+1+ans&lt;&lt;endl;
        return 0;
        //好，接下来一个应该是偶数然后是奇数
        //打个表看一看
        //还有一个就是说，如果现在还剩一个奇数，但是这一位要求一个偶数，那很难办，放在哪里都会打破平衡他本来的奇偶性，那么该怎么办呢。
        //奇数，那么想到的唯一一个办法就是少组两个，现在手里就肯定还会剩
        /*
        少组了两个，少组了两个是奇数和偶数
        这两个只可能是：
        偶数：两个奇数或者是一个偶数
        奇数：单个奇数
        那么可以把奇数拆掉，换成偶数前面的一个奇数
        还剩一个，
        还剩两个的情况呢?
        还剩两个刚好搞成一个偶数，还剩三个呢？
        还剩三个刚好两个，而且并不会引起问题
        还剩四个呢，四个的话就必须3+1，所以也只有两个
        五个呢，先2+1+2
        六个呢，就是2+1+2+1
        七个呢，就是2+1+3+1
        所以答案要先除以3
        除以3之后看除以3之后的余数
        比如说7/3余1 那么答案就是(7/3)*2
        四个呢 （4/3）*2
        如果余2呢
        （5/3）*2+1
        余0 （6/3）*2
        */
    }else{
        //剩下的情况就是说我现在偶数的数量比奇数的数量要多了，那么比较简单了，
        /*
        我先上一个偶数
        再上一个奇数
        如此反复，一直上到没有了奇数
        那我现在在上所有偶数
        上了多少个数了（奇数数量*2+1）
        */
       cout&lt;&lt;odd*2+1&lt;&lt;endl;
    }
    return 0;
}
</code></pre>
<h2 id="t3-just-stalling">T3 Just Stalling</h2>
<h4 id="题面描述-3">题面描述</h4>
<p>Farmer John 有 N 头奶牛（1≤N≤20），高度为 a1…aN。他的牛栏有 N 个牛棚，高度限制分别为 b1…bN（例如，如果 b5=17，那么一头高度不超过 17 的奶牛可以住在牛棚 5 里）。Farmer John 有多少种不同的方式安排他的奶牛，使得每头奶牛均住在不同的牛棚里，并且使得每个牛棚的高度限制均得到满足？</p>
<h4 id="输入格式从终端标准输入读入-3">输入格式（从终端/标准输入读入）：</h4>
<p>输入的第一行包含 N。第二行包含 N 个空格分隔的整数 a1,a2,…,aN。第三行包含 N 个空格分隔的整数 b1,b2,…,bN。所有的高度和高度限制均在范围 [1,109] 内。</p>
<h4 id="输出格式输出至终端标准输出-3">输出格式（输出至终端/标准输出）：</h4>
<p>输出 Farmer John 可以将每头奶牛安排到不同的牛棚里，使得每个牛棚的高度限制均得到满足的方法数。注意输出的数量可能需要使用 64 位整数型，例如 C++ 中的 long long。</p>
<h4 id="输入样例-2">输入样例：</h4>
<p>4<br>
1 2 3 4<br>
2 4 3 4</p>
<h4 id="输出样例-2">输出样例：</h4>
<p>8<br>
在这个例子中，我们不能将第三头奶牛安排到第一个牛棚里，因为 3=a3&gt;b1=2。类似地，我们不能将第四头奶牛安排到第一或第三个牛棚里。一种符合高度限制的安排方式为将奶牛 1 安排到牛棚 1，奶牛 2 安排到牛棚 2，奶牛 3 安排到牛棚 3，奶牛 4 安排到牛棚 4。</p>
<h4 id="测试点性质-2">测试点性质：</h4>
<p>测试点 1-5 满足 N≤8。<br>
测试点 6-12 没有额外限制。</p>
<h4 id="解题思路-2">解题思路</h4>
<p>其实，一开始的时候我这题根本就做不出来，因为我这一题将高度这个重要条件省略了，我直接用高度模拟出这个二分图中那两条边可以连接，然后一直在想优化暴力的方法。直到我突然想到，我的方法不论怎么优化，都必须把每一种方式都搜一遍，然后这个答案在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>long long</mtext></mrow><annotation encoding="application/x-tex">\text{long long}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord text"><span class="mord">long long</span></span></span></span></span>之内，不爆炸才怪。</p>
<p>然后，稍微看了一眼答案，感觉做法非常巧。</p>
<p>主要是强行构造乘法原理可以套上去的状态，然后再进行计算。</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define pb push_back
using namespace std;
template &lt;typename T&gt;inline void read(T&amp; t){
    t=0; register char ch=getchar();
    while(!('0'&lt;=ch&amp;&amp;ch&lt;='9')){if(ch=='-') t=-1;ch=getchar();}
    while(('0'&lt;=ch&amp;&amp;ch&lt;='9')){t=((t&lt;&lt;1)+(t&lt;&lt;3))+ch-'0'; ch=getchar();}
}
template &lt;typename T,typename... Args&gt; inline void read(T&amp; t, Args&amp;... args){
    read(t);read(args...);
}
template &lt;typename T&gt;inline void write(T x){
    if(x&lt;0) putchar('-'),x=~(x-1); int s[40],top=0;
    while(x) s[++top]=x%10,x/=10; if(!top) s[++top]=0;
    while(top) putchar(s[top--]+'0');
}
int n,a[114],b[514];
bool cmp(const int &amp;infoa,const int &amp;infob){
    return infoa&gt;infob;
}
long long ans=1;
int main(){
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;++i) cin&gt;&gt;a[i];
    for(int i=1;i&lt;=n;++i) cin&gt;&gt;b[i];
    sort(a+1,a+n+1,cmp);
    for(int i=1;i&lt;=n;++i){
        int sum=0;
        /*
        现在将奶牛的高度按降序来排一下。
        然后一个一个牛棚去考虑
        主要是想用乘法原理算。
        怎么算，就是说，我现在知道了
        第i个位置有sum个位置可以放。
        这时候会想到，i-1个位置中放的地方，一定在这sum个东西中间
        那么我这一位其实只sum-i+1种方法可以选择。这种方法是对的么？
        */
        for(int j=1;j&lt;=n;++j)
            if(b[j]&gt;=a[i]) sum++;
        ans*=(sum-i+1);
    }
    cout&lt;&lt;ans&lt;&lt;endl;
    return 0;
}
</code></pre>
<p>完结撒花！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2020 December Contest Bronze 题解]]></title>
        <id>https://mercurycity.github.io/post/2020-december-contest-bronze-ti-jie/</id>
        <link href="https://mercurycity.github.io/post/2020-december-contest-bronze-ti-jie/">
        </link>
        <updated>2021-07-03T06:44:25.000Z</updated>
        <content type="html"><![CDATA[<h2 id="t1-do-you-know-your-abcs">T1  Do You Know Your ABCs?</h2>
<h3 id="题面描述">题面描述：</h3>
<p>Farmer John 的奶牛正在 &quot;mooZ&quot; 视频会议平台上举行每日集会。她们发明了一个简单的数字游戏，为会议增添一些乐趣。</p>
<p>Elsie 有三个正整数 A、B 和 C（A≤B≤C）。这些数字是保密的，她不会直接透露给她的姐妹 Bessie。她告诉 Bessie 七个范围在 1…109 之间的整数（不一定各不相同），并宣称这是 A、B、C、A+B、B+C、C+A 和 A+B+C 的某种排列。</p>
<p>给定这七个整数，请帮助 Bessie 求出 A、B 和 C。可以证明，答案是唯一的。</p>
<h4 id="输入格式从终端标准输入读入">输入格式（从终端/标准输入读入）：</h4>
<p>输入一行，包含七个空格分隔的整数。</p>
<h4 id="输出格式输出至终端标准输出">输出格式（输出至终端/标准输出）：</h4>
<p>输出 A、B 和 C，用空格分隔。</p>
<h4 id="输入样例">输入样例：</h4>
<p>2 2 11 4 9 7 9</p>
<h4 id="输出样例">输出样例：</h4>
<p>2 2 7</p>
<h4 id="测试点性质">测试点性质：</h4>
<p>测试点 2-3 满足 C≤50。<br>
测试点 4-10 没有额外限制。</p>
<h4 id="解题思路">解题思路</h4>
<p>显然</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∀</mi><mtext>A,B,C</mtext><mo>∈</mo><mi mathvariant="double-struck">N</mi></mrow><annotation encoding="application/x-tex">\forall \text{\text{A,B,C}} \in \mathbb{N}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">∀</span><span class="mord text"><span class="mord text"><span class="mord">A,B,C</span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">N</span></span></span></span></span></span></p>
<p>所以，从小到大排序，然后最小的两个一定是ABC中的一个</p>
<p>然后就需要判断第三个是不是另外一个</p>
<p>然后会发现，当且仅当如果A+B刚好等于第三个时，那么这时第四个才是C<br>
其他情况，C必定为第三个。</p>
<p>简单思考题。</p>
<p>Code:</p>
<pre><code>die码当时没保存，┭┮﹏┭┮
</code></pre>
<h2 id="t2-daisy-chains">T2 Daisy Chains</h2>
<h3 id="题面描述-2">题面描述</h3>
<p>每天，作为她绕农场行走的一部分，奶牛 Bessie 会经过她最喜爱的草地，其中种有 N 朵花（五颜六色的雏菊），编号为 1…N（1≤N≤100），排列成一行。花 i 有 pi 朵花瓣（1≤pi≤1000）。<br>
作为一名崭露头角的摄影家，Bessie 决定给这些花拍些照片。具体地说，对于每一对满足 1≤i≤j≤N 的花 (i,j)，Bessie 会给从花 i 到花 j 之间的所有花（包括 i 和 j）拍一张照。</p>
<p>后来 Bessie 查看这些照片时注意到有些照片里存在「平均」的花——一朵恰好有 P 朵花瓣的花，其中 P 等于照片中所有花的花瓣数量的平均值。</p>
<p>Bessie 的照片中有几张存在平均的花？</p>
<h4 id="输入格式从终端标准输入读入-2">输入格式（从终端/标准输入读入）：</h4>
<p>输入的第一行包含 N。第二行包含 N 个空格分隔的整数 p1…pN。</p>
<h4 id="输出格式输出至终端标准输出-2">输出格式（输出至终端/标准输出）：</h4>
<p>输出存在平均的花的照片数量。</p>
<h4 id="输入样例-2">输入样例：</h4>
<p>4<br>
1 1 2 3</p>
<h4 id="输出样例-2">输出样例：</h4>
<p>6</p>
<h4 id="样例解释">样例解释</h4>
<p>每张仅包含一朵花的照片均会被计入答案（在这个样例中有 4 张）。另外，在这个样例中 (i,j) 为 (1,2) 和 (2,4) 所对应的照片也存在平均的花。</p>
<h4 id="解题思路-2">解题思路</h4>
<p>数据量很小，直接暴力模拟。</p>
<p>同样，die码没有保存。。</p>
<h2 id="t3-stuck-in-a-rut">T3 Stuck in a Rut</h2>
<h4 id="题面描述-3">题面描述</h4>
<p>Farmer John 最近扩大了他的农场，从奶牛们的角度看来这个农场相当于是无限大了！奶牛们将农场上放牧的区域想作是一个由正方形方格组成的无限大二维方阵，每个方格中均有美味的草（将每个方格看作是棋盘上的一个方格）。Farmer John 的 N 头奶牛（1≤N≤50）初始时位于不同的方格中，一部分朝向北面，一部分朝向东面。<br>
每一小时，每头奶牛会执行以下二者之一：</p>
<p>如果她当前所在的方格里的草已经被其他奶牛吃掉了，则她会停下。<br>
吃完她当前所在的方格中的所有草，并向她朝向的方向移动一个方格。<br>
经过一段时间，每头奶牛的身后会留下一条被啃秃了的轨迹。</p>
<p>如果两头奶牛在一次移动中移动到了同一个有草的方格，她们会分享这个方格中的草，并在下一个小时继续沿她们朝向的方向移动。</p>
<p>请求出每头奶牛吃到的草的数量。有些奶牛永远不会停下，从而吃到无限多的草。</p>
<h4 id="输入格式从终端标准输入读入-3">输入格式（从终端/标准输入读入）：</h4>
<p>输入的第一行包含 N。以下 N 行，每行描述一头奶牛的起始位置，包含一个字符 N（表示朝向北面） 或 E（表示朝向东面），以及两个非负整数 x 和 y（0≤x≤109，0≤y≤109）表示方格的坐标。所有 x 坐标各不相同，所有 y 坐标各不相同。<br>
为了使方向和坐标尽可能明确，如果一头奶牛位于方格 (x,y) 并向北移动，她会到达方格 (x,y+1)。如果她向东移动，她会到达方格 (x+1,y)。</p>
<h4 id="输出格式输出至终端标准输出-3">输出格式（输出至终端/标准输出）：</h4>
<p>输出 N 行。输出的第 i 行包含输入中的第 i 头奶牛吃到草的方格的数量。如果一头奶牛可以吃到无限多的草，为这头奶牛输出 &quot;Infinity&quot;。</p>
<h4 id="输入样例-3">输入样例：</h4>
<p>6<br>
E 3 5<br>
N 5 3<br>
E 4 6<br>
E 10 4<br>
N 11 2<br>
N 8 1</p>
<h4 id="输出样例-3">输出样例：</h4>
<p>5<br>
3<br>
Infinity<br>
Infinity<br>
2<br>
5</p>
<h4 id="测试点性质-2">测试点性质：</h4>
<p>测试点 2-5 中，所有坐标不超过 100。<br>
测试点 6-10 没有额外限制。</p>
<h4 id="解题思路-3">解题思路</h4>
<p>说实话，真是一道好（duliu）题。</p>
<p>做了很久，个人思路就是将可能会相遇的点全部保存下来，然后一个一个进行筛选。</p>
<p>筛选的时候要注意，你不能只用一个book数组记录哪一个点已经停了下来，而是应该继续记录那个点运动了多少，下一次如果运动不到应该运动到的相遇地方，就pass。</p>
<h4 id="蒟蒻die码">蒟蒻die码</h4>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define pb push_back
using namespace std;
template &lt;typename T&gt;inline void read(T&amp; t){
    t=0; register char ch=getchar();
    while(!('0'&lt;=ch&amp;&amp;ch&lt;='9')){if(ch=='-') t=-1;ch=getchar();}
    while(('0'&lt;=ch&amp;&amp;ch&lt;='9')){t=((t&lt;&lt;1)+(t&lt;&lt;3))+ch-'0'; ch=getchar();}
}
template &lt;typename T,typename... Args&gt; inline void read(T&amp; t, Args&amp;... args){
    read(t);read(args...);
}
template &lt;typename T&gt;inline void write(T x){
    if(x&lt;0) putchar('-'),x=~(x-1); int s[40],top=0;
    while(x) s[++top]=x%10,x/=10; if(!top) s[++top]=0;
    while(top) putchar(s[top--]+'0');
}
int n;
int dis[114514];
vector&lt;pair&lt;int,pair&lt;int,int&gt; &gt; &gt;Up,Right;
struct Meet{
    int x,y,lt,rt,mint;
    bool w;
    int ai,bi;
    bool operator &lt; (const Meet &amp;MeEt) const{
        return mint&lt;MeEt.mint;
    }
    void print(){
        cout&lt;&lt;lt&lt;&lt;' '&lt;&lt;rt&lt;&lt;' '&lt;&lt;mint&lt;&lt;' '&lt;&lt;w&lt;&lt;' '&lt;&lt;ai&lt;&lt;' '&lt;&lt;bi&lt;&lt;endl;;
    }
};
bool book[114514];
int boko[114514];
vector&lt;Meet&gt;meet;
int main(){
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;++i){
        char ch;
        cin&gt;&gt;ch;
        int x,y;
        read(x,y);
        if(ch=='E')
            Right.pb(make_pair(x,make_pair(y,i)));
        else
            Up.pb(make_pair(x,make_pair(y,i)));
    }
    for(int i=0;i&lt;Right.size();++i)
        for(int j=0;j&lt;Up.size();++j){
            #define x first
            #define y second.first
            #define idx second.second
            if(Right[i].x&gt;Up[j].x||Right[i].y&lt;Up[j].y) continue;
            int bx=Up[j].x,by=Right[i].y;
            meet.pb({bx,by,bx-Right[i].x,by-Up[j].y,min(bx-Right[i].x,by-Up[j].y),(bx-Right[i].x&lt;by-Up[j].y),Right[i].second.second,Up[j].second.second});
            #undef x
            #undef y
            #undef idx
        }
    sort(meet.begin(),meet.end());
    memset(book,0,sizeof(book));
    memset(dis,0x3f,sizeof(dis));
    for(int i=0;i&lt;meet.size();++i){
        if(book[meet[i].ai]||book[meet[i].bi]){
            //如果两个之中有一个之前已经被碰过了
            if(book[meet[i].ai]&amp;&amp;boko[meet[i].ai]/*向右的最大距离*/&lt;meet[i].x/*比我碰面的距离*/) continue;
            if(book[meet[i].bi]&amp;&amp;boko[meet[i].bi]/*向上的最大距离*/&lt;meet[i].y/*比我碰面的距离*/) continue;
           //这里的判断有问题，就是说，就算我有一个碰过了，但是草还是会被吃掉那个时候，所以很难搞
           //我一个book应该存的是，如果我停止了，那么我草吃到了哪里，而不是有没有被碰掉
           //book存完之后，就只需要判断一下我这个被碰过的点有没有走到那个位置就ok了。
        }
        if(meet[i].lt==meet[i].rt) continue;
        if(meet[i].w){
            dis[meet[i].bi]=meet[i].rt;
            book[meet[i].bi]=1;
            boko[meet[i].bi]=meet[i].y;//现在我这个是向上走的,并且我现在只可以走到meet[i].y的位置了。
        }else{
            dis[meet[i].ai]=meet[i].lt;
            book[meet[i].ai]=1;
            boko[meet[i].ai]=meet[i].x;//现在我这个是向上走的,并且我现在只可以走到meet[i].y的位置了。
        }
    }
    for(int i=1;i&lt;=n;++i) if(dis[i]==0x3f3f3f3f) cout&lt;&lt;&quot;Infinity&quot;&lt;&lt;'\n';
    else cout&lt;&lt;dis[i]&lt;&lt;'\n';
    return 0;
}
</code></pre>
]]></content>
    </entry>
</feed>