<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>2020 December Contest Bronze 题解 | Mercury的小屋</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://mercurycity.github.io/favicon.ico?v=1625494910862">
<link rel="stylesheet" href="https://mercurycity.github.io/styles/main.css">



<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="T1  Do You Know Your ABCs?
题面描述：
Farmer John 的奶牛正在 &quot;mooZ&quot; 视频会议平台上举行每日集会。她们发明了一个简单的数字游戏，为会议增添一些乐趣。
Elsie 有三个正整数..." />
    <meta name="keywords" content="USACO题解" />
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://mercurycity.github.io">
        <img src="https://mercurycity.github.io/images/avatar.png?v=1625494910862" class="site-logo">
        <h1 class="site-title">Mercury的小屋</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      刘玖拾的一个小屋，专门端捧刘玖拾的梦想。
    </div>
    <div class="site-footer">
      山登绝顶我为峰！ | <a class="rss" href="https://mercurycity.github.io/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">2020 December Contest Bronze 题解</h2>
            <div class="post-date">2021-07-03</div>
            
            <div class="post-content" v-pre>
              <h2 id="t1-do-you-know-your-abcs">T1  Do You Know Your ABCs?</h2>
<h3 id="题面描述">题面描述：</h3>
<p>Farmer John 的奶牛正在 &quot;mooZ&quot; 视频会议平台上举行每日集会。她们发明了一个简单的数字游戏，为会议增添一些乐趣。</p>
<p>Elsie 有三个正整数 A、B 和 C（A≤B≤C）。这些数字是保密的，她不会直接透露给她的姐妹 Bessie。她告诉 Bessie 七个范围在 1…109 之间的整数（不一定各不相同），并宣称这是 A、B、C、A+B、B+C、C+A 和 A+B+C 的某种排列。</p>
<p>给定这七个整数，请帮助 Bessie 求出 A、B 和 C。可以证明，答案是唯一的。</p>
<h4 id="输入格式从终端标准输入读入">输入格式（从终端/标准输入读入）：</h4>
<p>输入一行，包含七个空格分隔的整数。</p>
<h4 id="输出格式输出至终端标准输出">输出格式（输出至终端/标准输出）：</h4>
<p>输出 A、B 和 C，用空格分隔。</p>
<h4 id="输入样例">输入样例：</h4>
<p>2 2 11 4 9 7 9</p>
<h4 id="输出样例">输出样例：</h4>
<p>2 2 7</p>
<h4 id="测试点性质">测试点性质：</h4>
<p>测试点 2-3 满足 C≤50。<br>
测试点 4-10 没有额外限制。</p>
<h4 id="解题思路">解题思路</h4>
<p>显然</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∀</mi><mtext>A,B,C</mtext><mo>∈</mo><mi mathvariant="double-struck">N</mi></mrow><annotation encoding="application/x-tex">\forall \text{\text{A,B,C}} \in \mathbb{N}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">∀</span><span class="mord text"><span class="mord text"><span class="mord">A,B,C</span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68889em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbb">N</span></span></span></span></span></span></p>
<p>所以，从小到大排序，然后最小的两个一定是ABC中的一个</p>
<p>然后就需要判断第三个是不是另外一个</p>
<p>然后会发现，当且仅当如果A+B刚好等于第三个时，那么这时第四个才是C<br>
其他情况，C必定为第三个。</p>
<p>简单思考题。</p>
<p>Code:</p>
<pre><code>die码当时没保存，┭┮﹏┭┮
</code></pre>
<h2 id="t2-daisy-chains">T2 Daisy Chains</h2>
<h3 id="题面描述-2">题面描述</h3>
<p>每天，作为她绕农场行走的一部分，奶牛 Bessie 会经过她最喜爱的草地，其中种有 N 朵花（五颜六色的雏菊），编号为 1…N（1≤N≤100），排列成一行。花 i 有 pi 朵花瓣（1≤pi≤1000）。<br>
作为一名崭露头角的摄影家，Bessie 决定给这些花拍些照片。具体地说，对于每一对满足 1≤i≤j≤N 的花 (i,j)，Bessie 会给从花 i 到花 j 之间的所有花（包括 i 和 j）拍一张照。</p>
<p>后来 Bessie 查看这些照片时注意到有些照片里存在「平均」的花——一朵恰好有 P 朵花瓣的花，其中 P 等于照片中所有花的花瓣数量的平均值。</p>
<p>Bessie 的照片中有几张存在平均的花？</p>
<h4 id="输入格式从终端标准输入读入-2">输入格式（从终端/标准输入读入）：</h4>
<p>输入的第一行包含 N。第二行包含 N 个空格分隔的整数 p1…pN。</p>
<h4 id="输出格式输出至终端标准输出-2">输出格式（输出至终端/标准输出）：</h4>
<p>输出存在平均的花的照片数量。</p>
<h4 id="输入样例-2">输入样例：</h4>
<p>4<br>
1 1 2 3</p>
<h4 id="输出样例-2">输出样例：</h4>
<p>6</p>
<h4 id="样例解释">样例解释</h4>
<p>每张仅包含一朵花的照片均会被计入答案（在这个样例中有 4 张）。另外，在这个样例中 (i,j) 为 (1,2) 和 (2,4) 所对应的照片也存在平均的花。</p>
<h4 id="解题思路-2">解题思路</h4>
<p>数据量很小，直接暴力模拟。</p>
<p>同样，die码没有保存。。</p>
<h2 id="t3-stuck-in-a-rut">T3 Stuck in a Rut</h2>
<h4 id="题面描述-3">题面描述</h4>
<p>Farmer John 最近扩大了他的农场，从奶牛们的角度看来这个农场相当于是无限大了！奶牛们将农场上放牧的区域想作是一个由正方形方格组成的无限大二维方阵，每个方格中均有美味的草（将每个方格看作是棋盘上的一个方格）。Farmer John 的 N 头奶牛（1≤N≤50）初始时位于不同的方格中，一部分朝向北面，一部分朝向东面。<br>
每一小时，每头奶牛会执行以下二者之一：</p>
<p>如果她当前所在的方格里的草已经被其他奶牛吃掉了，则她会停下。<br>
吃完她当前所在的方格中的所有草，并向她朝向的方向移动一个方格。<br>
经过一段时间，每头奶牛的身后会留下一条被啃秃了的轨迹。</p>
<p>如果两头奶牛在一次移动中移动到了同一个有草的方格，她们会分享这个方格中的草，并在下一个小时继续沿她们朝向的方向移动。</p>
<p>请求出每头奶牛吃到的草的数量。有些奶牛永远不会停下，从而吃到无限多的草。</p>
<h4 id="输入格式从终端标准输入读入-3">输入格式（从终端/标准输入读入）：</h4>
<p>输入的第一行包含 N。以下 N 行，每行描述一头奶牛的起始位置，包含一个字符 N（表示朝向北面） 或 E（表示朝向东面），以及两个非负整数 x 和 y（0≤x≤109，0≤y≤109）表示方格的坐标。所有 x 坐标各不相同，所有 y 坐标各不相同。<br>
为了使方向和坐标尽可能明确，如果一头奶牛位于方格 (x,y) 并向北移动，她会到达方格 (x,y+1)。如果她向东移动，她会到达方格 (x+1,y)。</p>
<h4 id="输出格式输出至终端标准输出-3">输出格式（输出至终端/标准输出）：</h4>
<p>输出 N 行。输出的第 i 行包含输入中的第 i 头奶牛吃到草的方格的数量。如果一头奶牛可以吃到无限多的草，为这头奶牛输出 &quot;Infinity&quot;。</p>
<h4 id="输入样例-3">输入样例：</h4>
<p>6<br>
E 3 5<br>
N 5 3<br>
E 4 6<br>
E 10 4<br>
N 11 2<br>
N 8 1</p>
<h4 id="输出样例-3">输出样例：</h4>
<p>5<br>
3<br>
Infinity<br>
Infinity<br>
2<br>
5</p>
<h4 id="测试点性质-2">测试点性质：</h4>
<p>测试点 2-5 中，所有坐标不超过 100。<br>
测试点 6-10 没有额外限制。</p>
<h4 id="解题思路-3">解题思路</h4>
<p>说实话，真是一道好（duliu）题。</p>
<p>做了很久，个人思路就是将可能会相遇的点全部保存下来，然后一个一个进行筛选。</p>
<p>筛选的时候要注意，你不能只用一个book数组记录哪一个点已经停了下来，而是应该继续记录那个点运动了多少，下一次如果运动不到应该运动到的相遇地方，就pass。</p>
<h4 id="蒟蒻die码">蒟蒻die码</h4>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define pb push_back
using namespace std;
template &lt;typename T&gt;inline void read(T&amp; t){
    t=0; register char ch=getchar();
    while(!('0'&lt;=ch&amp;&amp;ch&lt;='9')){if(ch=='-') t=-1;ch=getchar();}
    while(('0'&lt;=ch&amp;&amp;ch&lt;='9')){t=((t&lt;&lt;1)+(t&lt;&lt;3))+ch-'0'; ch=getchar();}
}
template &lt;typename T,typename... Args&gt; inline void read(T&amp; t, Args&amp;... args){
    read(t);read(args...);
}
template &lt;typename T&gt;inline void write(T x){
    if(x&lt;0) putchar('-'),x=~(x-1); int s[40],top=0;
    while(x) s[++top]=x%10,x/=10; if(!top) s[++top]=0;
    while(top) putchar(s[top--]+'0');
}
int n;
int dis[114514];
vector&lt;pair&lt;int,pair&lt;int,int&gt; &gt; &gt;Up,Right;
struct Meet{
    int x,y,lt,rt,mint;
    bool w;
    int ai,bi;
    bool operator &lt; (const Meet &amp;MeEt) const{
        return mint&lt;MeEt.mint;
    }
    void print(){
        cout&lt;&lt;lt&lt;&lt;' '&lt;&lt;rt&lt;&lt;' '&lt;&lt;mint&lt;&lt;' '&lt;&lt;w&lt;&lt;' '&lt;&lt;ai&lt;&lt;' '&lt;&lt;bi&lt;&lt;endl;;
    }
};
bool book[114514];
int boko[114514];
vector&lt;Meet&gt;meet;
int main(){
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;++i){
        char ch;
        cin&gt;&gt;ch;
        int x,y;
        read(x,y);
        if(ch=='E')
            Right.pb(make_pair(x,make_pair(y,i)));
        else
            Up.pb(make_pair(x,make_pair(y,i)));
    }
    for(int i=0;i&lt;Right.size();++i)
        for(int j=0;j&lt;Up.size();++j){
            #define x first
            #define y second.first
            #define idx second.second
            if(Right[i].x&gt;Up[j].x||Right[i].y&lt;Up[j].y) continue;
            int bx=Up[j].x,by=Right[i].y;
            meet.pb({bx,by,bx-Right[i].x,by-Up[j].y,min(bx-Right[i].x,by-Up[j].y),(bx-Right[i].x&lt;by-Up[j].y),Right[i].second.second,Up[j].second.second});
            #undef x
            #undef y
            #undef idx
        }
    sort(meet.begin(),meet.end());
    memset(book,0,sizeof(book));
    memset(dis,0x3f,sizeof(dis));
    for(int i=0;i&lt;meet.size();++i){
        if(book[meet[i].ai]||book[meet[i].bi]){
            //如果两个之中有一个之前已经被碰过了
            if(book[meet[i].ai]&amp;&amp;boko[meet[i].ai]/*向右的最大距离*/&lt;meet[i].x/*比我碰面的距离*/) continue;
            if(book[meet[i].bi]&amp;&amp;boko[meet[i].bi]/*向上的最大距离*/&lt;meet[i].y/*比我碰面的距离*/) continue;
           //这里的判断有问题，就是说，就算我有一个碰过了，但是草还是会被吃掉那个时候，所以很难搞
           //我一个book应该存的是，如果我停止了，那么我草吃到了哪里，而不是有没有被碰掉
           //book存完之后，就只需要判断一下我这个被碰过的点有没有走到那个位置就ok了。
        }
        if(meet[i].lt==meet[i].rt) continue;
        if(meet[i].w){
            dis[meet[i].bi]=meet[i].rt;
            book[meet[i].bi]=1;
            boko[meet[i].bi]=meet[i].y;//现在我这个是向上走的,并且我现在只可以走到meet[i].y的位置了。
        }else{
            dis[meet[i].ai]=meet[i].lt;
            book[meet[i].ai]=1;
            boko[meet[i].ai]=meet[i].x;//现在我这个是向上走的,并且我现在只可以走到meet[i].y的位置了。
        }
    }
    for(int i=1;i&lt;=n;++i) if(dis[i]==0x3f3f3f3f) cout&lt;&lt;&quot;Infinity&quot;&lt;&lt;'\n';
    else cout&lt;&lt;dis[i]&lt;&lt;'\n';
    return 0;
}
</code></pre>

            </div>
            
              <div class="tag-container">
                
                  <a href="https://mercurycity.github.io/tag/wjmNtdxIB/" class="tag">
                    USACO题解
                  </a>
                
              </div>
            
            

            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>


  <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  <script>
    hljs.initHighlightingOnLoad()
  </script>





  </body>
</html>
