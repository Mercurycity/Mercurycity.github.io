<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>2021 January Contest Bronze 题解 | Mercury的小屋</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://mercurycity.github.io/favicon.ico?v=1625489074794">
<link rel="stylesheet" href="https://mercurycity.github.io/styles/main.css">



<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="T1 Uddered but not Herd
题面描述
一个鲜为人知的事实是，奶牛拥有自己的文字：「牛文」。牛文由 26 个字母 'a' 到 'z' 组成，但是当奶牛说牛文时，可能与我们所熟悉的 'abcdefghijklmnopqrst..." />
    <meta name="keywords" content="" />
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://mercurycity.github.io">
        <img src="https://mercurycity.github.io/images/avatar.png?v=1625489074794" class="site-logo">
        <h1 class="site-title">Mercury的小屋</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      刘玖拾的一个小屋，专门端捧刘玖拾的梦想。
    </div>
    <div class="site-footer">
      山登绝顶我为峰！ | <a class="rss" href="https://mercurycity.github.io/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">2021 January Contest Bronze 题解</h2>
            <div class="post-date">2021-07-04</div>
            
            <div class="post-content" v-pre>
              <h2 id="t1-uddered-but-not-herd">T1 Uddered but not Herd</h2>
<h4 id="题面描述">题面描述</h4>
<p>一个鲜为人知的事实是，奶牛拥有自己的文字：「牛文」。牛文由 26 个字母 'a' 到 'z' 组成，但是当奶牛说牛文时，可能与我们所熟悉的 'abcdefghijklmnopqrstuvwxyz' 不同，她会按某种特定的顺序排列字母。<br>
为了打发时间，奶牛 Bessie 在反复哼唱牛文字母歌，而 Farmer John 好奇她唱了多少遍。</p>
<p>给定一个小写字母组成的字符串，为 Farmer John 听到 Bessie 唱的字母，计算 Bessie 至少唱了几遍完整的牛文字母歌，使得 Farmer John 能够听到给定的字符串。Farmer John 并不始终注意 Bessie 所唱的内容，所以他可能会漏听 Bessie 唱过的一些字母。给定的字符串仅包含他记得他所听到的字母。</p>
<h4 id="输入格式从终端标准输入读入">输入格式（从终端/标准输入读入）：</h4>
<p>输入的第一行包含 26 个小写字母 'a' 到 'z' 的牛文字母表顺序。下一行包含一个小写字母组成的字符串，为 Farmer John 听到 Bessie 唱的字母。字符串的长度不小于 1 且不大于 1000。</p>
<h4 id="输出格式输出至终端标准输出">输出格式（输出至终端/标准输出）：</h4>
<p>输出 Bessie 所唱的完整的牛文字母歌的最小次数。</p>
<h4 id="输入样例">输入样例：</h4>
<p>abcdefghijklmnopqrstuvwxyz<br>
mood</p>
<h4 id="输出样例">输出样例：</h4>
<p>3</p>
<h4 id="样例解释">样例解释</h4>
<p>在这个样例中，牛文字母表与日常的字母表的排列一致。<br>
Bessie 至少唱了三遍牛文字母歌。有可能 Bessie 只唱了三遍牛文字母歌，而 Farmer John 听到了以下被标记为大写的字母。<br>
abcdefghijklMnOpqrstuvwxyz<br>
abcdefghijklmnOpqrstuvwxyz<br>
abcDefghijklmnopqrstuvwxyz</p>
<h4 id="测试点性质">测试点性质：</h4>
<p>测试点 2-5 中，牛文字母表与日常的字母表相同。<br>
测试点 6-10 没有额外限制。</p>
<p>试图直接用一个公式直接写出此题答案，罢了，根本不会写。</p>
<p>好的，那么这题的思路非常的显然，就是说，如果我现在这一位的字符对于前一位字符来说在字母表的较前位置，这显然是不合法的。同时，须要注意的是，如果现在又连续两位的字符，那么肯定是唱了两遍歌的毋庸置疑。</p>
<p>蒟蒻die码：</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define pb push_back
using namespace std;
template &lt;typename T&gt;inline void read(T&amp; t){
    t=0; register char ch=getchar();
    while(!('0'&lt;=ch&amp;&amp;ch&lt;='9')){if(ch=='-') t=-1;ch=getchar();}
    while(('0'&lt;=ch&amp;&amp;ch&lt;='9')){t=((t&lt;&lt;1)+(t&lt;&lt;3))+ch-'0'; ch=getchar();}
}
template &lt;typename T,typename... Args&gt; inline void read(T&amp; t, Args&amp;... args){
    read(t);read(args...);
}
template &lt;typename T&gt;inline void write(T x){
    if(x&lt;0) putchar('-'),x=~(x-1); int s[40],top=0;
    while(x) s[++top]=x%10,x/=10; if(!top) s[++top]=0;
    while(top) putchar(s[top--]+'0');
}
string st;
bool later(char ch1,char ch2){
    //写了一个函数来判断ch1是不是在ch2后
    //同时，如果ch1完全等于ch2时，这说明我读了两遍一个词，这直接累加答案
    if(ch1==ch2) return 1;
    for(int i=0;i&lt;st.size();++i){
        if(st[i]==ch1) return 0;
        if(st[i]==ch2) return 1;
    }
    return 0; //其实不会到这个时候了
}
int ans;
string st1;
int main(){
    cin&gt;&gt;st&gt;&gt;st1;
    char lch=st1[0];
    for(int i=1;i&lt;st1.size();++i){
        if(later(lch,st1[i])) ans++;
        lch=st1[i];
    }
    cout&lt;&lt;ans+1&lt;&lt;endl;
    return 0;
}
</code></pre>
<h2 id="t2-even-more-odd-photos">T2 Even More Odd Photos</h2>
<h4 id="题面描述-2">题面描述</h4>
<p>Farmer John 正再一次尝试给他的 N 头奶牛拍照（2≤N≤1000）。<br>
每头奶牛有一个范围在 1…100 之内的整数的「品种编号」。Farmer John 对他的照片有一个十分古怪的构思：他希望将所有的奶牛分为不相交的若干组（换句话说，将每头奶牛分到恰好一组中）并将这些组排成一行，使得第一组的奶牛的品种编号之和为偶数，第二组的编号之和为奇数，以此类推，奇偶交替。<br>
Farmer John 可以分成的最大组数是多少？</p>
<h4 id="输入格式从终端标准输入读入-2">输入格式（从终端/标准输入读入）：</h4>
<p>输入的第一行包含 N。下一行包含 N 个空格分隔的整数，为 N 头奶牛的品种编号。</p>
<h4 id="输出格式输出至终端标准输出-2">输出格式（输出至终端/标准输出）：</h4>
<p>输出 Farmer John 的照片中的最大组数。可以证明，至少存在一种符合要求的分组方案。</p>
<h4 id="输入样例1">输入样例1：</h4>
<p>7<br>
1 3 5 7 9 11 13</p>
<h4 id="输出样例1">输出样例1：</h4>
<p>3</p>
<h4 id="样例解释1">样例解释1</h4>
<p>在这个样例中，以下是一种分成最大组数三组的方案。将 1 和 3 分在第一组，5、7 和 9 分在第二组，11 和 13 分在第三组。</p>
<h4 id="输入样例2">输入样例2：</h4>
<p>7<br>
11 2 17 13 1 15 3</p>
<h4 id="输出样例2">输出样例2：</h4>
<p>5</p>
<h4 id="样例解释3">样例解释3：</h4>
<p>在这个样例中，以下是一种分成最大组数五组的方案。将 2 分在第一组，11 分在第二组，13 和 1 分在第三组，15 分在第四组，17 和 3 分在第五组。</p>
<h4 id="解题思路">解题思路：</h4>
<p>感觉就是一个大模拟，想了很久。详细内容不说了，见die码。附注，USACO给出的标准答案似乎die码复杂度比我的高：</p>
<p>算了，还是稍微讲一讲，避免未来又忘了这一题怎么做了。</p>
<p>首先的首先，会发现这一题其实数字大小没什么用，只是其奇偶性会改变很多。</p>
<p>ok首先，明显的一个贪心思路，就是说，如果我现在需要一个奇数，我肯定是上一个奇数，而不是上一个偶数加上一个奇数，因为明显，这个偶数可以放在后面一位来多创造一个价值。</p>
<p>根据这个思路，我现在先将偶数的数量和奇数的数量统计好。<br>
然后现在判断是偶数数量多还是奇数数量多。<br>
从简单开始，如果是偶数数量多，那么放偶数奇数偶数奇数，会发现放到最后一个奇数之后的那个偶数后，再多的偶数也只能叠加到前面去，创造不出一个新的奇数了，所以说这个答案比较简单，就是奇数数量*2+1。这是一个比较简单的情况。<br>
如果一样多，那么答案很显然就是两个数量加起来<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>n</mtext></mrow><annotation encoding="application/x-tex">\text{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord text"><span class="mord">n</span></span></span></span></span><br>
由简至繁，如果现在是奇数数量多。<br>
插一句题外话，为什么奇数数量多更加的复杂，其实很好理解，就是说，奇数数量多出来了，我两个奇数可以合成偶数，放一个奇数在别的地方会改变奇偶性，所以说明显是奇数数量多更加复杂。<br>
好，回归正题，如果是奇数数量多的时候呢。不妨把可以消耗的偶数全部消耗完毕（反正迟早也是必须的嘛。<br>
我现在的答案就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>n</mi><mi>s</mi><mo>×</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">ans\times 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>然后呢，我现在还剩奇数的个数减去偶数的个数个奇数（好像很绕）。<br>
假设我现在还剩<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>pos</mtext></mrow><annotation encoding="application/x-tex">\text{pos}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord text"><span class="mord">pos</span></span></span></span></span>个奇数，貌似是个找规律呢，打个表。</p>
<p>其实表格是有一个很好看的的，但是我不会写<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>LaTeX</mtext></mrow><annotation encoding="application/x-tex">\LaTeX</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.89883em;vertical-align:-0.2155em;"></span><span class="mord text"><span class="mord textrm">L</span><span class="mspace" style="margin-right:-0.36em;"></span><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.68333em;"><span style="top:-2.904999em;"><span class="pstrut" style="height:2.7em;"></span><span class="mord text"><span class="mord textrm sizing reset-size6 size3">A</span></span></span></span></span></span><span class="mspace" style="margin-right:-0.15em;"></span><span class="mord text"><span class="mord textrm">T</span><span class="mspace" style="margin-right:-0.1667em;"></span><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.46782999999999997em;"><span style="top:-2.7845em;"><span class="pstrut" style="height:3em;"></span><span class="mord text"><span class="mord textrm">E</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2155em;"><span></span></span></span></span><span class="mspace" style="margin-right:-0.125em;"></span><span class="mord textrm">X</span></span></span></span></span></span>，罢了罢了。<br>
pos	<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Δ</mi></mrow><annotation encoding="application/x-tex">\Delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Δ</span></span></span></span> ans<br>
1	 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mspace width="1em"/></mrow><annotation encoding="application/x-tex">\quad</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mspace" style="margin-right:1em;"></span></span></span></span>  -1<br>
2	 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mspace width="1em"/></mrow><annotation encoding="application/x-tex">\quad</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mspace" style="margin-right:1em;"></span></span></span></span>   1<br>
3    <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mspace width="1em"/></mrow><annotation encoding="application/x-tex">\quad</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mspace" style="margin-right:1em;"></span></span></span></span>   2<br>
4    <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mspace width="1em"/></mrow><annotation encoding="application/x-tex">\quad</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mspace" style="margin-right:1em;"></span></span></span></span>   1<br>
5    <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mspace width="1em"/></mrow><annotation encoding="application/x-tex">\quad</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mspace" style="margin-right:1em;"></span></span></span></span>   3<br>
6	 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mspace width="1em"/></mrow><annotation encoding="application/x-tex">\quad</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mspace" style="margin-right:1em;"></span></span></span></span>   4<br>
7    <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mspace width="1em"/></mrow><annotation encoding="application/x-tex">\quad</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mspace" style="margin-right:1em;"></span></span></span></span>   3</p>
<p>好，现在不难发现规律，规律就不用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>LaTeX</mtext></mrow><annotation encoding="application/x-tex">\LaTeX</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.89883em;vertical-align:-0.2155em;"></span><span class="mord text"><span class="mord textrm">L</span><span class="mspace" style="margin-right:-0.36em;"></span><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.68333em;"><span style="top:-2.904999em;"><span class="pstrut" style="height:2.7em;"></span><span class="mord text"><span class="mord textrm sizing reset-size6 size3">A</span></span></span></span></span></span><span class="mspace" style="margin-right:-0.15em;"></span><span class="mord text"><span class="mord textrm">T</span><span class="mspace" style="margin-right:-0.1667em;"></span><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.46782999999999997em;"><span style="top:-2.7845em;"><span class="pstrut" style="height:3em;"></span><span class="mord text"><span class="mord textrm">E</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2155em;"><span></span></span></span></span><span class="mspace" style="margin-right:-0.125em;"></span><span class="mord textrm">X</span></span></span></span></span></span>写了</p>
<p>蒟蒻die码：</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define pb push_back
using namespace std;
template &lt;typename T&gt;inline void read(T&amp; t){
    t=0; register char ch=getchar();
    while(!('0'&lt;=ch&amp;&amp;ch&lt;='9')){if(ch=='-') t=-1;ch=getchar();}
    while(('0'&lt;=ch&amp;&amp;ch&lt;='9')){t=((t&lt;&lt;1)+(t&lt;&lt;3))+ch-'0'; ch=getchar();}
}
template &lt;typename T,typename... Args&gt; inline void read(T&amp; t, Args&amp;... args){
    read(t);read(args...);
}
template &lt;typename T&gt;inline void write(T x){
    if(x&lt;0) putchar('-'),x=~(x-1); int s[40],top=0;
    while(x) s[++top]=x%10,x/=10; if(!top) s[++top]=0;
    while(top) putchar(s[top--]+'0');
}
int n;
int odd,even,ans;
int main(){
    cin&gt;&gt;n;
    while(n--){
        int t;
        read(t);
        if(t%2==0) even++;
        else odd++;
    }
    if(odd==even){
        cout&lt;&lt;odd&lt;&lt;endl;
        return 0;
    }
    //好，现在知道了这个过程，就模拟它
    //现在要构造第一组是偶数，第二组是奇数，就一直这样，那么先看是偶数多还是奇数多
    if(odd&gt;even){
        //奇数多，答案先累加一下偶数
        ans=even*2;
        //要贡献even个奇数
        odd=odd-even;
        if(odd%3==1)
            cout&lt;&lt;(odd/3)*2-1+ans&lt;&lt;endl;
        else 
            if(odd%3==0)
                cout&lt;&lt;(odd/3)*2+ans&lt;&lt;endl;
            else
                cout&lt;&lt;(odd/3)*2+1+ans&lt;&lt;endl;
        return 0;
        //好，接下来一个应该是偶数然后是奇数
        //打个表看一看
        //还有一个就是说，如果现在还剩一个奇数，但是这一位要求一个偶数，那很难办，放在哪里都会打破平衡他本来的奇偶性，那么该怎么办呢。
        //奇数，那么想到的唯一一个办法就是少组两个，现在手里就肯定还会剩
        /*
        少组了两个，少组了两个是奇数和偶数
        这两个只可能是：
        偶数：两个奇数或者是一个偶数
        奇数：单个奇数
        那么可以把奇数拆掉，换成偶数前面的一个奇数
        还剩一个，
        还剩两个的情况呢?
        还剩两个刚好搞成一个偶数，还剩三个呢？
        还剩三个刚好两个，而且并不会引起问题
        还剩四个呢，四个的话就必须3+1，所以也只有两个
        五个呢，先2+1+2
        六个呢，就是2+1+2+1
        七个呢，就是2+1+3+1
        所以答案要先除以3
        除以3之后看除以3之后的余数
        比如说7/3余1 那么答案就是(7/3)*2
        四个呢 （4/3）*2
        如果余2呢
        （5/3）*2+1
        余0 （6/3）*2
        */
    }else{
        //剩下的情况就是说我现在偶数的数量比奇数的数量要多了，那么比较简单了，
        /*
        我先上一个偶数
        再上一个奇数
        如此反复，一直上到没有了奇数
        那我现在在上所有偶数
        上了多少个数了（奇数数量*2+1）
        */
       cout&lt;&lt;odd*2+1&lt;&lt;endl;
    }
    return 0;
}
</code></pre>
<h2 id="t3-just-stalling">T3 Just Stalling</h2>
<h4 id="题面描述-3">题面描述</h4>
<p>Farmer John 有 N 头奶牛（1≤N≤20），高度为 a1…aN。他的牛栏有 N 个牛棚，高度限制分别为 b1…bN（例如，如果 b5=17，那么一头高度不超过 17 的奶牛可以住在牛棚 5 里）。Farmer John 有多少种不同的方式安排他的奶牛，使得每头奶牛均住在不同的牛棚里，并且使得每个牛棚的高度限制均得到满足？</p>
<h4 id="输入格式从终端标准输入读入-3">输入格式（从终端/标准输入读入）：</h4>
<p>输入的第一行包含 N。第二行包含 N 个空格分隔的整数 a1,a2,…,aN。第三行包含 N 个空格分隔的整数 b1,b2,…,bN。所有的高度和高度限制均在范围 [1,109] 内。</p>
<h4 id="输出格式输出至终端标准输出-3">输出格式（输出至终端/标准输出）：</h4>
<p>输出 Farmer John 可以将每头奶牛安排到不同的牛棚里，使得每个牛棚的高度限制均得到满足的方法数。注意输出的数量可能需要使用 64 位整数型，例如 C++ 中的 long long。</p>
<h4 id="输入样例-2">输入样例：</h4>
<p>4<br>
1 2 3 4<br>
2 4 3 4</p>
<h4 id="输出样例-2">输出样例：</h4>
<p>8<br>
在这个例子中，我们不能将第三头奶牛安排到第一个牛棚里，因为 3=a3&gt;b1=2。类似地，我们不能将第四头奶牛安排到第一或第三个牛棚里。一种符合高度限制的安排方式为将奶牛 1 安排到牛棚 1，奶牛 2 安排到牛棚 2，奶牛 3 安排到牛棚 3，奶牛 4 安排到牛棚 4。</p>
<h4 id="测试点性质-2">测试点性质：</h4>
<p>测试点 1-5 满足 N≤8。<br>
测试点 6-12 没有额外限制。</p>
<h4 id="解题思路-2">解题思路</h4>
<p>其实，一开始的时候我这题根本就做不出来，因为我这一题将高度这个重要条件省略了，我直接用高度模拟出这个二分图中那两条边可以连接，然后一直在想优化暴力的方法。直到我突然想到，我的方法不论怎么优化，都必须把每一种方式都搜一遍，然后这个答案在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>long long</mtext></mrow><annotation encoding="application/x-tex">\text{long long}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord text"><span class="mord">long long</span></span></span></span></span>之内，不爆炸才怪。</p>
<p>然后，稍微看了一眼答案，感觉做法非常巧。</p>
<p>主要是强行构造乘法原理可以套上去的状态，然后再进行计算。</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
#define pb push_back
using namespace std;
template &lt;typename T&gt;inline void read(T&amp; t){
    t=0; register char ch=getchar();
    while(!('0'&lt;=ch&amp;&amp;ch&lt;='9')){if(ch=='-') t=-1;ch=getchar();}
    while(('0'&lt;=ch&amp;&amp;ch&lt;='9')){t=((t&lt;&lt;1)+(t&lt;&lt;3))+ch-'0'; ch=getchar();}
}
template &lt;typename T,typename... Args&gt; inline void read(T&amp; t, Args&amp;... args){
    read(t);read(args...);
}
template &lt;typename T&gt;inline void write(T x){
    if(x&lt;0) putchar('-'),x=~(x-1); int s[40],top=0;
    while(x) s[++top]=x%10,x/=10; if(!top) s[++top]=0;
    while(top) putchar(s[top--]+'0');
}
int n,a[114],b[514];
bool cmp(const int &amp;infoa,const int &amp;infob){
    return infoa&gt;infob;
}
long long ans=1;
int main(){
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;++i) cin&gt;&gt;a[i];
    for(int i=1;i&lt;=n;++i) cin&gt;&gt;b[i];
    sort(a+1,a+n+1,cmp);
    for(int i=1;i&lt;=n;++i){
        int sum=0;
        /*
        现在将奶牛的高度按降序来排一下。
        然后一个一个牛棚去考虑
        主要是想用乘法原理算。
        怎么算，就是说，我现在知道了
        第i个位置有sum个位置可以放。
        这时候会想到，i-1个位置中放的地方，一定在这sum个东西中间
        那么我这一位其实只sum-i+1种方法可以选择。这种方法是对的么？
        */
        for(int j=1;j&lt;=n;++j)
            if(b[j]&gt;=a[i]) sum++;
        ans*=(sum-i+1);
    }
    cout&lt;&lt;ans&lt;&lt;endl;
    return 0;
}
</code></pre>
<p>完结撒花！</p>

            </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://mercurycity.github.io/post/2020-december-contest-bronze-ti-jie/">
                  <h3 class="post-title">
                    2020 December Contest Bronze 题解
                  </h3>
                </a>
              </div>
            

            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>






  </body>
</html>
